<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David Bindel (program), Andrew Appel (proof)">

<title>Simple Finite Element Method in C</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#shape-functions" id="toc-shape-functions" class="nav-link" data-scroll-target="#shape-functions">Shape functions</a></li>
  <li><a href="#mesh-geometry" id="toc-mesh-geometry" class="nav-link" data-scroll-target="#mesh-geometry">Mesh geometry</a>
  <ul class="collapse">
  <li><a href="#memory-management" id="toc-memory-management" class="nav-link" data-scroll-target="#memory-management">Memory management</a></li>
  <li><a href="#meshes-in-1d" id="toc-meshes-in-1d" class="nav-link" data-scroll-target="#meshes-in-1d">Meshes in 1D</a></li>
  <li><a href="#quad-meshes-in-2d" id="toc-quad-meshes-in-2d" class="nav-link" data-scroll-target="#quad-meshes-in-2d">Quad meshes in 2D</a></li>
  <li><a href="#d-triangular-meshes" id="toc-d-triangular-meshes" class="nav-link" data-scroll-target="#d-triangular-meshes">2D triangular meshes</a></li>
  <li><a href="#reference-to-spatial-mapping" id="toc-reference-to-spatial-mapping" class="nav-link" data-scroll-target="#reference-to-spatial-mapping">Reference to spatial mapping</a></li>
  <li><a href="#io-routines" id="toc-io-routines" class="nav-link" data-scroll-target="#io-routines">I/O routines</a></li>
  </ul></li>
  <li><a href="#quadrature-rules" id="toc-quadrature-rules" class="nav-link" data-scroll-target="#quadrature-rules">Quadrature rules</a>
  <ul class="collapse">
  <li><a href="#gaussian-legendre-quadrature-rules" id="toc-gaussian-legendre-quadrature-rules" class="nav-link" data-scroll-target="#gaussian-legendre-quadrature-rules">Gaussian-Legendre quadrature rules</a></li>
  <li><a href="#product-gauss-rules" id="toc-product-gauss-rules" class="nav-link" data-scroll-target="#product-gauss-rules">Product Gauss rules</a></li>
  <li><a href="#mid-side-rule" id="toc-mid-side-rule" class="nav-link" data-scroll-target="#mid-side-rule">Mid-side rule</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  </ul></li>
  <li><a href="#assembly" id="toc-assembly" class="nav-link" data-scroll-target="#assembly">Assembly</a>
  <ul class="collapse">
  <li><a href="#matrix-assembler-interface" id="toc-matrix-assembler-interface" class="nav-link" data-scroll-target="#matrix-assembler-interface">Matrix assembler interface</a></li>
  <li><a href="#vector-assembly-interface" id="toc-vector-assembly-interface" class="nav-link" data-scroll-target="#vector-assembly-interface">Vector assembly interface</a></li>
  <li><a href="#method-dispatch" id="toc-method-dispatch" class="nav-link" data-scroll-target="#method-dispatch">Method dispatch</a></li>
  <li><a href="#matrix-assembly-loops" id="toc-matrix-assembly-loops" class="nav-link" data-scroll-target="#matrix-assembly-loops">Matrix assembly loops</a></li>
  <li><a href="#vector-assembly" id="toc-vector-assembly" class="nav-link" data-scroll-target="#vector-assembly">Vector assembly</a></li>
  </ul></li>
  <li><a href="#finite-element-mesh" id="toc-finite-element-mesh" class="nav-link" data-scroll-target="#finite-element-mesh">Finite element mesh</a>
  <ul class="collapse">
  <li><a href="#mesh-operations" id="toc-mesh-operations" class="nav-link" data-scroll-target="#mesh-operations">Mesh operations</a></li>
  <li><a href="#implementation-1" id="toc-implementation-1" class="nav-link" data-scroll-target="#implementation-1">Implementation</a></li>
  </ul></li>
  <li><a href="#elements" id="toc-elements" class="nav-link" data-scroll-target="#elements">Elements</a>
  <ul class="collapse">
  <li><a href="#method-dispatch-1" id="toc-method-dispatch-1" class="nav-link" data-scroll-target="#method-dispatch-1">Method dispatch</a></li>
  <li><a href="#d-poisson-element" id="toc-d-poisson-element" class="nav-link" data-scroll-target="#d-poisson-element">1D Poisson element</a></li>
  <li><a href="#poisson-elements-in-2d" id="toc-poisson-elements-in-2d" class="nav-link" data-scroll-target="#poisson-elements-in-2d">Poisson elements in 2D</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simple Finite Element Method in C</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David Bindel (program), Andrew Appel (proof) </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This document is automatically extracted from the sources found at <a href="https://github.com/VeriNum/simple_cfem" class="uri">https://github.com/VeriNum/simple_cfem</a>. The code is written as a pedagogical example, and is coded in C to make it a reasonable target for verification with the Verified Software Toolchain.</p>
<p><a href="proofdoc/index.html">The correctness proof is described here</a>.</p>
<p>The C program is in two parts. Basic linear algebra functions are in the LAProof library:</p>
<ul>
<li><a href="https://verinum.org/LAProof/alloc.html"><code>alloc</code>: Memory allocation</a></li>
<li><a href="https://verinum.org/LAProof/densemat.html"><code>densemat</code>: Dense matrix operations</a></li>
<li><a href="https://verinum.org/LAProof/bandmat.html"><code>bandmat</code>: Band matrix operations</a></li>
</ul>
<p>The rest of this page is the C program.</p>
</section>
<section id="shape-functions" class="level1">
<h1>Shape functions</h1>
<p>A <em>shape function</em> on a reference domain is a basis function used for interpolation on that domain. We will generally use Lagrange shape functions (also called nodal shape functions), which are one at one nodal point in a reference domain and zero at the others. We want to be able to compute both the values of all shape functions at a point in the domain and also their derivatives (stored as a matris with <span class="math inline">\(d\)</span> columns for a <span class="math inline">\(d\)</span>-dimensional reference domain). Our shape function implementations all have the following interface, where the output arguments <code>N</code> and <code>dN</code> are used to store the shape function values and derivative values. If a <code>NULL</code> is given for either of these output arguments, we just skip that part of the computation.</p>
<p>The function returns the number of shape functions it computes.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="op">(*</span>shapes_t<span class="op">)(</span><span class="dt">double</span><span class="op">*,</span> <span class="dt">double</span><span class="op">*,</span> <span class="dt">double</span><span class="op">*);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Our 1D shape functions are Lagrange polynomials for equally-spaced nodes in the interval <span class="math inline">\([-1, 1]\)</span>. We only go up to cubic polynomials (<span class="math inline">\(p = 3)\)</span>, as high-order polynomial interpolation through equally-spaced points is poorly behaved. When finite element codes implement very high order elements, they usually use a non-equispaced mesh (e.g.&nbsp;Gauss-Lobatto-Legendre nodes) that are better behaved for interpolation.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes1dP1<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes1dP2<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes1dP3<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The 2D P1 and P2 shape functions are tensor products of 1D P1 and P2 elements. The nodes are ordered counterclockwise, starting with the bottom left corner of the square. Thus, the P1 element has the reference domain <span class="math inline">\([-1,1]^2\)</span> and nodal points at the corners:</p>
<pre><code>3 -- 2
|    |
0 -- 1</code></pre>
<p>while for the P2 element, we include the mid-side nodes and one node in the middle (listed last):</p>
<pre><code>6 -- 5 -- 4
|         |
7    8    3
|         |
0 -- 1 -- 2</code></pre>
<p>The S2 element (part of the “serendipity family”) is identical to the P2 element except that it does not include the final node in the middle.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes2dP1<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes2dP2<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes2dS2<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Finally, we define shape functions for a triangle with the reference domain with corners at <span class="math inline">\((0,0)\)</span>, <span class="math inline">\((0,1)\)</span>, and <span class="math inline">\((1,0)\)</span>, listed in that order.</p>
<pre><code>2
| \
0--1</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes2dT1<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="mesh-geometry" class="level1">
<h1>Mesh geometry</h1>
<p>A mesh consists of an array of nodes locations <span class="math inline">\(x_j \in
\mathbb{R}^d\)</span> and an element connectivity array with <code>elt[i,j]</code> giving the node number for the <span class="math inline">\(i\)</span>th node of the <span class="math inline">\(j\)</span>th element.</p>
<p>Each element represents a subset of <span class="math inline">\(\Omega_e \subset \mathbb{R}^d\)</span> that is the image of a reference domain <span class="math inline">\(\Omega_0 \subset
\mathbb{R}^d\)</span> under a mapping <span class="math display">\[
  \chi(\xi) = \sum_{i=1}^{m} N^e_i(\xi) x_i
\]</span> where <span class="math inline">\(x_1, \ldots, x_m\)</span> are the <span class="math inline">\(m\)</span> element node positions. The functions <span class="math inline">\(N^e_i\)</span> are nodal basis functions (or Lagrange basis functions, or cardinal functions) for an interpolation set <span class="math inline">\(\xi_1,
\ldots, \xi_m \in \Omega_0\)</span>; that is <span class="math inline">\(N_i(\xi_j) = \delta_{ij}\)</span>. The reference domain nodes <span class="math inline">\(\xi_i\)</span> are typically placed at corners or on edges of the reference domain, and their images are at corresponding locations in <span class="math inline">\(\Omega_e\)</span>.</p>
<p>When the same set of nodal basis functions (also called nodal shape functions in a finite element setting) are used both for defining the geometry and for approximating a PDE solution on <span class="math inline">\(\Omega\)</span>, we call this method of describing the geometry an <em>isoparametric</em> map.</p>
<p>We generally want our mappings describing the geometry to be <em>positively oriented</em>: that is, the map <span class="math inline">\(\chi\)</span> should be invertible and have positive Jacobian determinant over all of <span class="math inline">\(\Omega_0\)</span>. This puts some restrictions on the spatial positions of the nodes; for example, if the interpolation nodes appear in counterclockwise order in the reference domain <span class="math inline">\(\Omega_0\)</span>, then the corresponding spatial nodes in <span class="math inline">\(\Omega_e\)</span> should also appear in counterclockwise. order.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> mesh_t <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mesh storage</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> X<span class="op">;</span>  <span class="co">// Node locations (d-by-numnp)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> elt<span class="op">;</span>   <span class="co">// Element connectivity array (nen-by-numelt)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Dimensions</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d<span class="op">;</span>       <span class="co">// Spatial dimension of problem</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp<span class="op">;</span>   <span class="co">// Number of nodal points</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen<span class="op">;</span>     <span class="co">// Number of element nodes</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numelt<span class="op">;</span>  <span class="co">// Number of elements</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Shape function</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">(*</span>shape<span class="op">)(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="op">*</span>mesh_t<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>One <em>can</em> allocate objects and then work out the node positions and element connectivity by hand (or with an external program). But in many cases, a simpler option is to programatically generate a mesh that covers a simple domain (e.g.&nbsp;a block) and then map the locations of the nodes. One can construct more complex meshes by combining this with a “tie” operation that merges the identity of nodes in the same location, but we will not bother with tied meshes for now.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_malloc<span class="op">(</span><span class="dt">int</span> d<span class="op">,</span> <span class="dt">int</span> numnp<span class="op">,</span> <span class="dt">int</span> nen<span class="op">,</span> <span class="dt">int</span> numelt<span class="op">);</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_free<span class="op">(</span>mesh_t mesh<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The simplest mesher creates a 1D mesh on an interval <span class="math inline">\([a,b]\)</span>. We allow elements of order 1-3.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_create1d<span class="op">(</span><span class="dt">int</span> numelt<span class="op">,</span> <span class="dt">int</span> degree<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Things are more complicated in 2D, and we have distinct mesh generation routines for the different types of shape functions described in the <code>shapes</code> module. Each of these generates a mesh of the region <span class="math inline">\([0,1]^2\)</span> with <code>nex</code>-by-<code>ney</code> elements.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_block2d_P1<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_block2d_P2<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">);</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_block2d_S2<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">);</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_block2d_T1<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Given a mesh and a point in a reference geometry (given by an element identifier <code>eltid</code> and coordinates <code>xref</code> in the element’s reference domain), we would like to be able to compute spatial quantities (the shape functions, their spatial derivatives, and the Jacobian of the reference to spatial map). The Jacobian matrix is in LU-factored form.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_to_spatial<span class="op">(</span>mesh_t mesh<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> xref<span class="op">,</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">double</span><span class="op">*</span> x<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ipiv<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> J<span class="op">,</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>We frequently are interested just in the mapped point location, shape functions and mapped derivatives, and the Jacobian determinant. So we provide a convenience wrapper around <code>mesh_to_spatial</code> for this case.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> mesh_shapes<span class="op">(</span>mesh_t mesh<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">,</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                   <span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For debugging, it is helpful to be able to print out all or part of the mesh geometry.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print_nodes<span class="op">(</span>mesh_t mesh<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print_elt<span class="op">(</span>mesh_t mesh<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print<span class="op">(</span>mesh_t mesh<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="memory-management" class="level2">
<h2 class="anchored" data-anchor-id="memory-management">Memory management</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_malloc<span class="op">(</span><span class="dt">int</span> d<span class="op">,</span> <span class="dt">int</span> numnp<span class="op">,</span> <span class="dt">int</span> nen<span class="op">,</span> <span class="dt">int</span> numelt<span class="op">)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    mesh_t mesh <span class="op">=</span> surely_malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> mesh_t<span class="op">));</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>d      <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>numnp  <span class="op">=</span> numnp<span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>nen    <span class="op">=</span> nen<span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>numelt <span class="op">=</span> numelt<span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>X      <span class="op">=</span> double_calloc<span class="op">(</span>d   <span class="op">*</span> numnp<span class="op">);</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>elt    <span class="op">=</span> int_calloc<span class="op">(</span>nen <span class="op">*</span> numelt<span class="op">);</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>shape  <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mesh<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_free<span class="op">(</span>mesh_t mesh<span class="op">)</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>mesh<span class="op">-&gt;</span>elt<span class="op">);</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>mesh<span class="op">-&gt;</span>X<span class="op">);</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>mesh<span class="op">);</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="meshes-in-1d" class="level2">
<h2 class="anchored" data-anchor-id="meshes-in-1d">Meshes in 1D</h2>
<p>The simplest mesher creates a 1D mesh on an interval <span class="math inline">\([a,b]\)</span>. Elements are ordered from left to right. We allow elements of order 1-3.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_create1d<span class="op">(</span><span class="dt">int</span> numelt<span class="op">,</span> <span class="dt">int</span> degree<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> numelt <span class="op">*</span> degree <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen <span class="op">=</span> degree <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    mesh_t mesh <span class="op">=</span> mesh_malloc<span class="op">(</span><span class="dv">1</span><span class="op">,</span> numnp<span class="op">,</span> nen<span class="op">,</span> numelt<span class="op">);</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>      <span class="op">(</span>degree <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> mesh<span class="op">-&gt;</span>shape <span class="op">=</span> shapes1dP1<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>degree <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> mesh<span class="op">-&gt;</span>shape <span class="op">=</span> shapes1dP2<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>degree <span class="op">==</span> <span class="dv">3</span><span class="op">)</span> mesh<span class="op">-&gt;</span>shape <span class="op">=</span> shapes1dP3<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> assert<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up equispaced mesh of points</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> X <span class="op">=</span> mesh<span class="op">-&gt;</span>X<span class="op">;</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        X<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>i<span class="op">*</span>b <span class="op">+</span> <span class="op">(</span>numnp<span class="op">-</span>i<span class="op">-</span><span class="dv">1</span><span class="op">)*</span>a<span class="op">)/(</span>numnp<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up element connectivity</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> elt <span class="op">=</span> mesh<span class="op">-&gt;</span>elt<span class="op">;</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> numelt<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>            elt<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>nen<span class="op">]</span> <span class="op">=</span> i<span class="op">+</span>j<span class="op">*(</span>nen<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mesh<span class="op">;</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="quad-meshes-in-2d" class="level2">
<h2 class="anchored" data-anchor-id="quad-meshes-in-2d">Quad meshes in 2D</h2>
<p>All the 2D quad meshers produce meshes of <code>nex</code> by <code>ney</code> elements, ordered in row-major order starting in the southwest and proceeding to the northeast. The nodes are listed going counterclockwise around the element (except possibly the last node in the P2 case).</p>
<p>We start with the P1 case, which is the simplest (only corner nodes).</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_block2d_P1<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nx <span class="op">=</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">,</span> ny <span class="op">=</span> ney<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    mesh_t mesh <span class="op">=</span> mesh_malloc<span class="op">(</span><span class="dv">2</span><span class="op">,</span> nx<span class="op">*</span>ny<span class="op">,</span> <span class="dv">4</span><span class="op">,</span> nex<span class="op">*</span>ney<span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>shape <span class="op">=</span> shapes2dP1<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up nodes (row-by-row, SW to NE)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iy <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iy <span class="op">&lt;</span> ney<span class="op">+</span><span class="dv">1</span><span class="op">;</span> <span class="op">++</span>iy<span class="op">)</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*(</span>nex<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> ix<span class="op">)/(</span>nx<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> iy<span class="op">)/(</span>ny<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up element connectivity</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iy <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iy <span class="op">&lt;</span> ney<span class="op">;</span> <span class="op">++</span>iy<span class="op">)</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nex<span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*</span>nex<span class="op">;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i_sw <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*(</span>nex<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">4</span><span class="op">*</span>i<span class="op">+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i_sw<span class="op">;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">4</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">4</span><span class="op">*</span>i<span class="op">+</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">4</span><span class="op">*</span>i<span class="op">+</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mesh<span class="op">;</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For P2 elements, each element involves three consecutive rows and columns of the logical array of nodes. This at least remains mostly straightforward.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_block2d_P2<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nx <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>nex<span class="op">+</span><span class="dv">1</span><span class="op">,</span> ny <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>ney<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    mesh_t mesh <span class="op">=</span> mesh_malloc<span class="op">(</span><span class="dv">2</span><span class="op">,</span> nx<span class="op">*</span>ny<span class="op">,</span> <span class="dv">9</span><span class="op">,</span> nex<span class="op">*</span>ney<span class="op">);</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>shape <span class="op">=</span> shapes2dP2<span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up nodes (row-by-row, SW to NE)</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iy <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iy <span class="op">&lt;</span> ny<span class="op">;</span> <span class="op">++</span>iy<span class="op">)</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nx<span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*</span>nx<span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> ix<span class="op">)/(</span>nx<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> iy<span class="op">)/(</span>ny<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up element connectivity</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iy <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iy <span class="op">&lt;</span> ney<span class="op">;</span> <span class="op">++</span>iy<span class="op">)</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nex<span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*</span>nex<span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i_sw <span class="op">=</span> <span class="op">(</span><span class="dv">2</span><span class="op">*</span>ix<span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="dv">2</span><span class="op">*</span>iy<span class="op">)*</span>nx<span class="op">;</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i_sw<span class="op">;</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> nx<span class="op">;</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>nx<span class="op">;</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>nx<span class="op">;</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">6</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span>   <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>nx<span class="op">;</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span>   <span class="op">+</span> nx<span class="op">;</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">9</span><span class="op">*</span>i<span class="op">+</span><span class="dv">8</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> nx<span class="op">;</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mesh<span class="op">;</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The serendipity element block mesher is a little more complicated than P1 or P2, because we don’t have a regular grid of mesh points (because we don’t need mesh points in the middle of our elements.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_block2d_S2<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nx0 <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>nex<span class="op">+</span><span class="dv">1</span><span class="op">,</span> nx1 <span class="op">=</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">;</span> <span class="co">// Even/odd row sizes</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> <span class="op">(</span>ney<span class="op">+</span><span class="dv">1</span><span class="op">)*</span>nx0 <span class="op">+</span> ney<span class="op">*</span>nx1<span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    mesh_t mesh <span class="op">=</span> mesh_malloc<span class="op">(</span><span class="dv">2</span><span class="op">,</span> numnp<span class="op">,</span> <span class="dv">8</span><span class="op">,</span> nex<span class="op">*</span>ney<span class="op">);</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>shape <span class="op">=</span> shapes2dS2<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up nodes (row-by-row, SW to NE)</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iy <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iy <span class="op">&lt;</span> ney<span class="op">;</span> <span class="op">++</span>iy<span class="op">)</span> <span class="op">{</span> <span class="co">// Element row index</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> start <span class="op">=</span> iy<span class="op">*(</span>nx0<span class="op">+</span>nx1<span class="op">);</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill bottom row</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nx0<span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*(</span>start<span class="op">+</span>ix<span class="op">)+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> ix<span class="op">)/(</span>nx0<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*(</span>start<span class="op">+</span>ix<span class="op">)+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> iy<span class="op">)/</span>ney<span class="op">;</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill middle row</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        start <span class="op">+=</span> nx0<span class="op">;</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nx1<span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*(</span>start<span class="op">+</span>ix<span class="op">)+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> ix<span class="op">)/(</span>nx1<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*(</span>start<span class="op">+</span>ix<span class="op">)+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> iy<span class="op">+</span><span class="fl">0.5</span><span class="op">)/</span>ney<span class="op">;</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill top row (may get overwritten by the same values shortly</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>        start <span class="op">+=</span> nx1<span class="op">;</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nx0<span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*(</span>start<span class="op">+</span>ix<span class="op">)+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> ix<span class="op">)/(</span>nx0<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*(</span>start<span class="op">+</span>ix<span class="op">)+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> iy<span class="op">+</span><span class="fl">1.0</span><span class="op">)/</span>ney<span class="op">;</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up element connectivity</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iy <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iy <span class="op">&lt;</span> ney<span class="op">;</span> <span class="op">++</span>iy<span class="op">)</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nex<span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*</span>nex<span class="op">;</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i_sw <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>ix <span class="op">+</span> iy<span class="op">*(</span>nx0<span class="op">+</span>nx1<span class="op">);</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i_ww <span class="op">=</span>   ix <span class="op">+</span> iy<span class="op">*(</span>nx0<span class="op">+</span>nx1<span class="op">)</span> <span class="op">+</span> nx0<span class="op">;</span></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i_nw <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>ix <span class="op">+</span> iy<span class="op">*(</span>nx0<span class="op">+</span>nx1<span class="op">)</span> <span class="op">+</span> nx0<span class="op">+</span>nx1<span class="op">;</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">8</span><span class="op">*</span>i<span class="op">+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i_sw<span class="op">;</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">8</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">8</span><span class="op">*</span>i<span class="op">+</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">8</span><span class="op">*</span>i<span class="op">+</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> i_ww <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">8</span><span class="op">*</span>i<span class="op">+</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> i_nw <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">8</span><span class="op">*</span>i<span class="op">+</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> i_nw <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">8</span><span class="op">*</span>i<span class="op">+</span><span class="dv">6</span><span class="op">]</span> <span class="op">=</span> i_nw<span class="op">;</span></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">8</span><span class="op">*</span>i<span class="op">+</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> i_ww<span class="op">;</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mesh<span class="op">;</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="d-triangular-meshes" class="level2">
<h2 class="anchored" data-anchor-id="d-triangular-meshes">2D triangular meshes</h2>
<p>The 2D linear triangle mesher is like the P1 mesher, but each quad is comprised of two triangles with a common edge going from the southeast to the northwest edge of the quad.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>mesh_t mesh_block2d_T1<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nx <span class="op">=</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">,</span> ny <span class="op">=</span> ney<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    mesh_t mesh <span class="op">=</span> mesh_malloc<span class="op">(</span><span class="dv">2</span><span class="op">,</span> nx<span class="op">*</span>ny<span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">*</span>nex<span class="op">*</span>ney<span class="op">);</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    mesh<span class="op">-&gt;</span>shape <span class="op">=</span> shapes2dT1<span class="op">;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up nodes (row-by-row, SW to NE)</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iy <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iy <span class="op">&lt;</span> ney<span class="op">+</span><span class="dv">1</span><span class="op">;</span> <span class="op">++</span>iy<span class="op">)</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*(</span>nex<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> ix<span class="op">)/(</span>nx<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>X<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span> iy<span class="op">)/(</span>ny<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up element connectivity</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> iy <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iy <span class="op">&lt;</span> ney<span class="op">;</span> <span class="op">++</span>iy<span class="op">)</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> nex<span class="op">;</span> <span class="op">++</span>ix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*</span>nex<span class="op">;</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i_sw <span class="op">=</span> ix <span class="op">+</span> iy<span class="op">*(</span>nex<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Two triangles makes a square</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">6</span><span class="op">*</span>i<span class="op">+</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i_sw<span class="op">;</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">6</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">6</span><span class="op">*</span>i<span class="op">+</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">6</span><span class="op">*</span>i<span class="op">+</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">6</span><span class="op">*</span>i<span class="op">+</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">-&gt;</span>elt<span class="op">[</span><span class="dv">6</span><span class="op">*</span>i<span class="op">+</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> i_sw <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> nex<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mesh<span class="op">;</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="reference-to-spatial-mapping" class="level2">
<h2 class="anchored" data-anchor-id="reference-to-spatial-mapping">Reference to spatial mapping</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_to_spatial<span class="op">(</span>mesh_t mesh<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> xref<span class="op">,</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">double</span><span class="op">*</span> x<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ipiv<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> J<span class="op">,</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> mesh<span class="op">-&gt;</span>d<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> elt <span class="op">=</span> mesh<span class="op">-&gt;</span>elt <span class="op">+</span> mesh<span class="op">-&gt;</span>nen <span class="op">*</span> eltid<span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> X <span class="op">=</span> mesh<span class="op">-&gt;</span>X<span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get shape function</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nshape <span class="op">=</span> <span class="op">(*</span>mesh<span class="op">-&gt;</span>shape<span class="op">)(</span>N<span class="op">,</span> dN<span class="op">,</span> xref<span class="op">);</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build x if requested</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&amp;&amp;</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        memset<span class="op">(</span>x<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> d <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> nshape<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> d<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>                x<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> X<span class="op">[</span>i<span class="op">+</span>d<span class="op">*</span>elt<span class="op">[</span>k<span class="op">]]</span> <span class="op">*</span> N<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build and factor J and transform dN if requested</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ipiv <span class="op">&amp;&amp;</span> J <span class="op">&amp;&amp;</span> dN<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Form J</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>        memset<span class="op">(</span>J<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> d <span class="op">*</span> d <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> nshape<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> d<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>                    J<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>d<span class="op">]</span> <span class="op">+=</span> X<span class="op">[</span>i<span class="op">+</span>d<span class="op">*</span>elt<span class="op">[</span>k<span class="op">]]</span> <span class="op">*</span> dN<span class="op">[</span>k<span class="op">+</span>j<span class="op">*</span>nshape<span class="op">];</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Factor</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>        densematn_lufactor<span class="op">(</span>ipiv<span class="op">,</span> J<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Transform shape derivatives to spatial coordinates</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> nshape<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> dNk<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>                dNk<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dN<span class="op">[</span>k<span class="op">+</span>j<span class="op">*</span>nshape<span class="op">];</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>            densematn_lusolveT<span class="op">(</span>ipiv<span class="op">,</span> J<span class="op">,</span> dNk<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>                dN<span class="op">[</span>k<span class="op">+</span>j<span class="op">*</span>nshape<span class="op">]</span> <span class="op">=</span> dNk<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> mesh_shapes<span class="op">(</span>mesh_t mesh<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">,</span></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>                   <span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">)</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Allocate space to make a 3D element work</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ipiv<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> J<span class="op">[</span><span class="dv">9</span><span class="op">];</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> xout<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> mesh<span class="op">-&gt;</span>d<span class="op">;</span></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Call mesh_to_spatial</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>    mesh_to_spatial<span class="op">(</span>mesh<span class="op">,</span> eltid<span class="op">,</span> x<span class="op">,</span> xout<span class="op">,</span> ipiv<span class="op">,</span> J<span class="op">,</span> N<span class="op">,</span> dN<span class="op">);</span></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>    memcpy<span class="op">(</span>x<span class="op">,</span> xout<span class="op">,</span> d <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If we asked for J, return the Jacobian</span></span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dN <span class="op">?</span> densematn_lujac<span class="op">(</span>ipiv<span class="op">,</span> J<span class="op">,</span> d<span class="op">)</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="io-routines" class="level2">
<h2 class="anchored" data-anchor-id="io-routines">I/O routines</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print_nodes<span class="op">(</span>mesh_t mesh<span class="op">)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Nodal positions:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"   ID "</span><span class="op">);</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> mesh<span class="op">-&gt;</span>d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"     X</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> mesh<span class="op">-&gt;</span>numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%3d</span><span class="st"> : "</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span><span class="op">*</span> Xi <span class="op">=</span> mesh<span class="op">-&gt;</span>X <span class="op">+</span> mesh<span class="op">-&gt;</span>d<span class="op">*</span>i<span class="op">;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> mesh<span class="op">-&gt;</span>d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">" </span><span class="sc">%6.2g</span><span class="st">"</span><span class="op">,</span> Xi<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print_elt<span class="op">(</span>mesh_t mesh<span class="op">)</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Element connectivity:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> mesh<span class="op">-&gt;</span>numelt<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">% 3d</span><span class="st"> :"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> mesh<span class="op">-&gt;</span>nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"  </span><span class="sc">% 3d</span><span class="st">"</span><span class="op">,</span> mesh<span class="op">-&gt;</span>elt<span class="op">[</span>j <span class="op">+</span> i<span class="op">*(</span>mesh<span class="op">-&gt;</span>nen<span class="op">)]);</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print<span class="op">(</span>mesh_t mesh<span class="op">)</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    mesh_print_nodes<span class="op">(</span>mesh<span class="op">);</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>    mesh_print_elt<span class="op">(</span>mesh<span class="op">);</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="quadrature-rules" class="level1">
<h1>Quadrature rules</h1>
<p>Quadrature rules approximate integrals with formulas of the form <span class="math display">\[
  \int_{\Omega} f(x) \, d\Omega(x) \approx
  \sum_{j=1}^p f(\xi_{j}) w_j
\]</span> where <span class="math inline">\(\xi_j \in \Omega\)</span> and <span class="math inline">\(w_j \in \mathbb{R}\)</span> are known as the quadrature nodes (or points) and weights, respectively.</p>
<p>A good source of quadrature rules for various domains can be found in Stroud’s book on <em>Approximate calculation of multiple integrals</em> (Prentice Hall, 1971).</p>
<section id="gaussian-legendre-quadrature-rules" class="level2">
<h2 class="anchored" data-anchor-id="gaussian-legendre-quadrature-rules">Gaussian-Legendre quadrature rules</h2>
<p>Gauss-Legendre quadrature rules (sometimes just called Gauss quadrature rules when the context is clear) are <span class="math inline">\(p\)</span>-point rules on <span class="math inline">\([-1, 1]\)</span> that are characterized by the fact that they are exact when <span class="math inline">\(f\)</span> is a polynomial of degree at most <span class="math inline">\(2p-1\)</span>.</p>
<p>Gauss-Legendre nodes are zeros of Legendre polynomials, while the weights can be computed via an eigenvalue decomposition (using the Golub-Welsch algorithm). However, we do not need very high-order quadrature rules, and so only provide nodes and weights for rules up to <span class="math inline">\(p = 10\)</span> (probably more than we need), which are tabulated in many places. Because this is just a table lookup, we don’t bother to include the code in the automated documentation.</p>
<p>Note that our code uses zero-based indexing (C-style) for indexing the quadrature nodes, even though the expression we wrote above uses the one-based indexing more common in presentations in the numerical methods literature.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> gauss_point<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">);</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> gauss_weight<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="product-gauss-rules" class="level2">
<h2 class="anchored" data-anchor-id="product-gauss-rules">Product Gauss rules</h2>
<p>A 2D tensor product Gauss rule for the domain <span class="math inline">\([-1,1]^2\)</span> involves a grid of quadrature points with coordinates given by 1D Gauss quadrature rules. We support rules with 1, 4, 9, or 16 points.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> gauss2d_point<span class="op">(</span><span class="dt">double</span><span class="op">*</span> xi<span class="op">,</span> <span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">);</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> gauss2d_weight<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="mid-side-rule" class="level2">
<h2 class="anchored" data-anchor-id="mid-side-rule">Mid-side rule</h2>
<p>For a triangle, a rule based on the three mid-side values is exact for every polynomial with total degree less than or equal to 2 (which is enough for our purposes). This is sometimes called the Hughes formula.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> hughes_point<span class="op">(</span><span class="dt">double</span><span class="op">*</span> xi<span class="op">,</span> <span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">);</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> hughes_weight<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">int</span> gauss2d_npoint1d<span class="op">(</span><span class="dt">int</span> npts<span class="op">)</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>npts<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span>  <span class="dv">1</span><span class="op">:</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span>  <span class="dv">4</span><span class="op">:</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span>  <span class="dv">9</span><span class="op">:</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">16</span><span class="op">:</span> <span class="cf">return</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">25</span><span class="op">:</span> <span class="cf">return</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">"</span><span class="sc">%d</span><span class="st"> quadrature points unsupported by rule</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> npts<span class="op">);</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        exit<span class="op">(-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> gauss2d_point<span class="op">(</span><span class="dt">double</span><span class="op">*</span> xi<span class="op">,</span> <span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">)</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> gauss2d_npoint1d<span class="op">(</span>npts<span class="op">);</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ix <span class="op">=</span> i<span class="op">%</span>d<span class="op">,</span> iy <span class="op">=</span> i<span class="op">/</span>d<span class="op">;</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    xi<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> gauss_point<span class="op">(</span>ix<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    xi<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> gauss_point<span class="op">(</span>iy<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> gauss2d_weight<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">)</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> gauss2d_npoint1d<span class="op">(</span>npts<span class="op">);</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ix <span class="op">=</span> i<span class="op">%</span>d<span class="op">,</span> iy <span class="op">=</span> i<span class="op">/</span>d<span class="op">;</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gauss_weight<span class="op">(</span>ix<span class="op">,</span> d<span class="op">)</span> <span class="op">*</span> gauss_weight<span class="op">(</span>iy<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>We only implement one triangle quadrature (the three-point Hughes rule).</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> hughes_point<span class="op">(</span><span class="dt">double</span><span class="op">*</span> xi<span class="op">,</span> <span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        xi<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        xi<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        xi<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        xi<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        xi<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        xi<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>        fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">"Quadrature node index out of bounds</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>        exit<span class="op">(-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> hughes_weight<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">)</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.0</span><span class="op">/</span><span class="fl">6.0</span><span class="op">;</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="assembly" class="level1">
<h1>Assembly</h1>
<p>Each element in a finite element discretization consists of</p>
<ul>
<li>A domain <span class="math inline">\(\Omega_e\)</span> for the <span class="math inline">\(e\)</span>th element, and</li>
<li>Local shape functions <span class="math inline">\(N^e_1, \ldots, N^e_m\)</span>, which are often Lagrange functions for interpolation at some set of nodes in <span class="math inline">\(\Omega_e\)</span>.</li>
</ul>
<p>Each local shape function on the domain <span class="math inline">\(\Omega_e\)</span> is the restriction of some global shape function on the whole domain <span class="math inline">\(\Omega\)</span>. That is, we have global shape functions <span class="math display">\[
  N_{j}(x) = \sum_{j = \iota(j',e)} N^e_{j'}(x),
\]</span> where <span class="math inline">\(\iota(j,e)\)</span> denotes the mapping from the local shape function index for element <span class="math inline">\(e\)</span> to the corresponding global shape function index. We only ever compute explicitly with the local functions <span class="math inline">\(N^e_j\)</span>; the global functions are implicit.</p>
<p><em>Assembly</em> is the process of reconstructing a quantity defined in terms of global shape functions from the contributions of the individual elements and their local shape functions. For example, to compute <span class="math display">\[
  F_i = \int_{\Omega} f(x) N_i(x) \, dx,
\]</span> we rewrite the integral as <span class="math display">\[
  F_i = \sum_{i = \iota(i',e)} \int_{\Omega_e} f(x) N^e_{i'}(x) \, dx.
\]</span> In code, this is separated into two pieces:</p>
<ul>
<li>Compute element contributions <span class="math inline">\(\int_{\Omega_e} f(x) N^e_{i'}(x) \, dx\)</span>. This is the responsibility of the element implementation.</li>
<li>Sum contributions into the global position <span class="math inline">\(i\)</span> corresponding to the element-local index <span class="math inline">\(i'\)</span>. This is managed by an assembly loop.</li>
</ul>
<p>The concept of an “assembly loop” is central to finite element methods, but it is not unique to this setting. For example, circuit simulators similarly construct system matrices (conductance, capacitance, etc) via the contributions of circuit elements (resistors, capacitors, inductors, and so forth).</p>
<p>We have two types of assembly loops that we care about: those that involve pairs of shape functions and result in matrices, and those that explicitly involve only a single shape function and result in vectors.</p>
<p>We will sometimes also want to discard some element contributions that correspond to interactions with shape functions associated with known boundary values (for example). We also handle this filtering work as part of our assembly process.</p>
<section id="matrix-assembler-interface" class="level2">
<h2 class="anchored" data-anchor-id="matrix-assembler-interface">Matrix assembler interface</h2>
<p>There are several matrix formats that we might want to target as outputs for assembling a matrix; these include dense storage, banded storage, coordinate form, or CSR. Because we would like to re-use the same assembly loop logic with these different formats, we define an abstract <code>assemble_t</code> interface with two basic methods:</p>
<ul>
<li><code>add(assembler, ematrix, ids, ne)</code> adds the <code>ne</code>-by-<code>ne</code> element matrix (<code>ematrix</code>) into the global structure referenced by the assembler. The <code>ids</code> array implements the map <span class="math inline">\(\iota\)</span> from local indices to global indices (i.e.&nbsp;<code>ids[ilocal] = iglobal</code>).</li>
<li><code>clear(assembler)</code> sets the matrix to zero, preserving the sparsity pattern (“graph”).</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Interface for general assembler object (callback + context)</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> assemble_data_t <span class="op">*</span>assemble_data_t<span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> assemble_t <span class="op">{</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    assemble_data_t p<span class="op">;</span>                            <span class="co">// Context</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>add<span class="op">)(</span>assemble_data_t<span class="op">,</span> <span class="dt">double</span><span class="op">*,</span> <span class="dt">int</span><span class="op">*,</span> <span class="dt">int</span><span class="op">);</span> <span class="co">// Add contribution</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>clear<span class="op">)(</span>assemble_data_t<span class="op">);</span> <span class="co">// set to zero</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="op">(*</span>norm2<span class="op">)(</span>assemble_data_t<span class="op">);</span> <span class="co">// square of Frobenius norm</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>print<span class="op">)(</span>assemble_data_t<span class="op">);</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="op">*</span>assemble_t<span class="op">;</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Convenience functions that call the assembler methods</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_add<span class="op">(</span>assemble_t assembler<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">);</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_clear<span class="op">(</span>assemble_t assembler<span class="op">);</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> assemble_norm2<span class="op">(</span>assemble_t assembler<span class="op">);</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_print<span class="op">(</span>assemble_t assembler<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>We currently only support two types of assemblers: dense and band. In all cases, we assume that the dimension <code>n</code> of the matrix is big enough (all active indices are less than <code>n</code>). For the band assembler, we do check to make sure there are no contributions that are outside the band (and error out if a contribution does live outside the expected band).</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_assemble_dense<span class="op">(</span>assemble_t assembler<span class="op">,</span> densemat_t A<span class="op">);</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_assemble_band<span class="op">(</span>assemble_t assembler<span class="op">,</span> bandmat_t b<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="vector-assembly-interface" class="level2">
<h2 class="anchored" data-anchor-id="vector-assembly-interface">Vector assembly interface</h2>
<p>We only really use one vector representation (a simple array), so there is no need for the same type of assembler abstraction for vectors that we have for matrices. The semantics of <code>assemble_vector</code> are similar to those of <code>assemble_add</code> in the matrix case, except now we add the element vector <code>ve</code> into the global vector <code>v</code>.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_vector<span class="op">(</span><span class="dt">double</span><span class="op">*</span> v<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> ve<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="method-dispatch" class="level2">
<h2 class="anchored" data-anchor-id="method-dispatch">Method dispatch</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_add<span class="op">(</span>assemble_t assembler<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">)</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>assembler<span class="op">-&gt;</span>add<span class="op">))(</span>assembler<span class="op">-&gt;</span>p<span class="op">,</span> emat<span class="op">,</span> ids<span class="op">,</span> ne<span class="op">);</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_clear <span class="op">(</span>assemble_t assembler<span class="op">)</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>assembler<span class="op">-&gt;</span>clear<span class="op">))(</span>assembler<span class="op">-&gt;</span>p<span class="op">);</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> assemble_norm2 <span class="op">(</span>assemble_t assembler<span class="op">)</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="op">(*(</span>assembler<span class="op">-&gt;</span>norm2<span class="op">))(</span>assembler<span class="op">-&gt;</span>p<span class="op">);</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> assemble_norm <span class="op">(</span>assemble_t assembler<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sqrt<span class="op">(</span>assemble_norm2<span class="op">(</span>assembler<span class="op">));</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_print <span class="op">(</span>assemble_t assembler<span class="op">)</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>assembler<span class="op">-&gt;</span>print<span class="op">))(</span>assembler<span class="op">-&gt;</span>p<span class="op">);</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Setting up an assembler object just involves initializing the data pointer <code>p</code> and setting up the method table.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare private implementations for the methods</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> assemble_dense_add<span class="op">(</span>assemble_data_t p<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">);</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> assemble_bandmat_add<span class="op">(</span>assemble_data_t p<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">);</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Initialize a dense assembler</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> casted_densemat_clear<span class="op">(</span>assemble_data_t p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  densemat_clear <span class="op">((</span>densemat_t<span class="op">)</span>p<span class="op">);</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> casted_densemat_norm2<span class="op">(</span>assemble_data_t p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> densemat_norm2 <span class="op">((</span>densemat_t<span class="op">)</span>p<span class="op">);</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> casted_densemat_print<span class="op">(</span>assemble_data_t p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>  densemat_print <span class="op">((</span>densemat_t<span class="op">)</span>p<span class="op">);</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_assemble_dense<span class="op">(</span>assemble_t assembler<span class="op">,</span> densemat_t A<span class="op">)</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>p <span class="op">=</span> <span class="op">(</span>assemble_data_t<span class="op">)</span>A<span class="op">;</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>add <span class="op">=</span> assemble_dense_add<span class="op">;</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>clear <span class="op">=</span> casted_densemat_clear<span class="op">;</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>norm2 <span class="op">=</span> casted_densemat_norm2<span class="op">;</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>print <span class="op">=</span> casted_densemat_print<span class="op">;</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="co">// Initialize a band assembler</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> casted_bandmat_clear<span class="op">(</span>assemble_data_t p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>  bandmat_clear <span class="op">((</span>bandmat_t<span class="op">)</span>p<span class="op">);</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> casted_bandmat_norm2<span class="op">(</span>assemble_data_t p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> bandmat_norm2 <span class="op">((</span>bandmat_t<span class="op">)</span>p<span class="op">);</span></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> casted_bandmat_print<span class="op">(</span>assemble_data_t p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>  bandmat_print <span class="op">((</span>bandmat_t<span class="op">)</span>p<span class="op">);</span></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_assemble_band<span class="op">(</span>assemble_t assembler<span class="op">,</span> bandmat_t b<span class="op">)</span></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>p <span class="op">=</span> <span class="op">(</span>assemble_data_t<span class="op">)</span>b<span class="op">;</span></span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>add <span class="op">=</span> assemble_bandmat_add<span class="op">;</span></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>clear <span class="op">=</span> casted_bandmat_clear<span class="op">;</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>norm2 <span class="op">=</span> casted_bandmat_norm2<span class="op">;</span></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>print <span class="op">=</span> casted_bandmat_print<span class="op">;</span></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="matrix-assembly-loops" class="level2">
<h2 class="anchored" data-anchor-id="matrix-assembly-loops">Matrix assembly loops</h2>
<p>The assembly loops logically execute <code>A[iglobal, jglobal] += Ae[i, j]</code> for every local index pair <code>(i,j)</code>. We filter out the contributions where the global indices are negative (indicating that these contributions are not needed because of an essential boundary condition.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> assemble_dense_add<span class="op">(</span>assemble_data_t p<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">)</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    densemat_t A <span class="op">=</span> <span class="op">(</span>densemat_t<span class="op">)</span>p<span class="op">;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> je <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> je <span class="op">&lt;</span> ne<span class="op">;</span> <span class="op">++</span>je<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> ids<span class="op">[</span>je<span class="op">];</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ie <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ie <span class="op">&lt;=</span> je<span class="op">;</span> <span class="op">++</span>ie<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ids<span class="op">[</span>ie<span class="op">];</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">&gt;=</span> i<span class="op">)</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>          densemat_addto<span class="op">(</span>A<span class="op">,</span>i<span class="op">,</span>j<span class="op">,</span> emat<span class="op">[</span>ie<span class="op">+</span>ne<span class="op">*</span>je<span class="op">]);</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> assemble_bandmat_add<span class="op">(</span>assemble_data_t p<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">)</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    bandmat_t P <span class="op">=</span> <span class="op">(</span>bandmat_t<span class="op">)</span>p<span class="op">;</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> P<span class="op">-&gt;</span>m<span class="op">;</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b <span class="op">=</span> P<span class="op">-&gt;</span>b<span class="op">;</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> je <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> je <span class="op">&lt;</span> ne<span class="op">;</span> <span class="op">++</span>je<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> ids<span class="op">[</span>je<span class="op">];</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ie <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ie <span class="op">&lt;=</span> je<span class="op">;</span> <span class="op">++</span>ie<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ids<span class="op">[</span>ie<span class="op">];</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> d <span class="op">=</span> j<span class="op">-</span>i<span class="op">;</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> d <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>                assert<span class="op">(</span>d <span class="op">&lt;=</span> b<span class="op">);</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>        bandmat_addto<span class="op">(</span>P<span class="op">,</span>j<span class="op">,</span>d<span class="op">,</span> emat<span class="op">[</span>ie<span class="op">+</span>ne<span class="op">*</span>je<span class="op">]);</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="vector-assembly" class="level2">
<h2 class="anchored" data-anchor-id="vector-assembly">Vector assembly</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_vector<span class="op">(</span><span class="dt">double</span><span class="op">*</span> v<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> ve<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ie <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ie <span class="op">&lt;</span> ne<span class="op">;</span> <span class="op">++</span>ie<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i <span class="op">=</span> ids<span class="op">[</span>ie<span class="op">];</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>            v<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> ve<span class="op">[</span>ie<span class="op">];</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="finite-element-mesh" class="level1">
<h1>Finite element mesh</h1>
<p>My finite element mesh data structure is informed by lots of old Fortran codes, and mostly is a big pile of arrays. Specifically, we have the nodal arrays:</p>
<ul>
<li><code>U</code>: Global array of solution values, <em>including</em> those that are determined by Dirichlet boundary conditions. Column <span class="math inline">\(j\)</span> represents the unknowns at node <span class="math inline">\(j\)</span> in the mesh.</li>
<li><code>F</code>: Global array of load values (right hand side evaluations of the forcing function in Poisson, for example; but Neumann boundary conditions can also contribute to <code>F</code>).</li>
<li><code>id</code>: Indices of solution values in a reduced solution vector. One column per node, with the same dimensions as <code>U</code> (and <code>F</code>), so that <code>ureduced[id[i,j]]</code> corresponds to <code>U[i,j]</code> when <code>id[i,j]</code> is nonnegative. The reduced solution vector contains only those variables that are not constrained a priori by boundary conditions; we mark the latter with negative entries in the <code>id</code> array.</li>
</ul>
<p>We also keep around a pointer to a mesh and an element type object. Note that for the moment, we are assuming only one element type per problem – we could have a separate array of element type pointer (one per element) if we wanted more flexibility.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> fem_t <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mesh data</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> mesh_t <span class="op">*</span>mesh<span class="op">;</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Element type (NB: can generalize with multiple types)</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> element_t <span class="op">*</span>etype<span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Storage for fields</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> U<span class="op">;</span>  <span class="co">// Global array of solution values (ndof-by-numnp)</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> F<span class="op">;</span>  <span class="co">// Global array of forcing values (ndof-by-numnp)</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> id<span class="op">;</span>    <span class="co">// Global to reduced ID map (ndof-by-numnp)</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Dimensions</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof<span class="op">;</span>    <span class="co">// Number of unknowns per nodal point (tested only with ndof = 1)</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nactive<span class="op">;</span> <span class="co">// Number of active dofs</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="op">*</span>fem_t<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="mesh-operations" class="level2">
<h2 class="anchored" data-anchor-id="mesh-operations">Mesh operations</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>fem_t fem_malloc<span class="op">(</span>mesh_t mesh<span class="op">,</span> <span class="dt">int</span> ndof<span class="op">);</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_free<span class="op">(</span>fem_t fe<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>fem_assign_ids</code> function sets up the <code>id</code> array. On input, the <code>id</code> array in the mesh structure should be initialized so that boundary values are marked with negative numbers (and everything else non-negative). On output, entries of the <code>id</code> array for variables not subject to essential boundary conditions will be assigned indices from 0 to <code>nactive</code> (and <code>nactive</code> will be updated appropriately).</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb37"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fem_assign_ids<span class="op">(</span>fem_t fe<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>fem_update_U</code> function applies an update to the internal state. By update, we mean that <code>U[i,j] -= du_red[id[i,j]]</code> for <code>id[i,j] &gt; 0</code>.</p>
<p>If the update comes from <span class="math inline">\(K^{-1} R\)</span> where <span class="math inline">\(K\)</span> is the reduced tangent and <span class="math inline">\(R\)</span> is the reduced residual, then applying the update will exactly solve the equation in the linear case. However, we can also apply approximate updates (e.g.&nbsp;with an inexact solver for <span class="math inline">\(K\)</span>), and the same framework works for Newton iterations for nonlinear problems.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_update_U<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> du_red<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>fem_set_load</code> function iterates through all nodes in the mesh, and for each node calls a callback function. The arguments to the callback are the node position (an input argument) and the node loading / right-hand side vector (an output argument).</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb39"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_set_load<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">void</span> <span class="op">(*</span>f<span class="op">)(</span><span class="dt">double</span><span class="op">*</span> x<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> fx<span class="op">));</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The assembly loops iterate through the elements and produce a global residual and tangent stiffness based on the current solution state. The residual and tangent matrix assembler are passed in by pointers; a <code>NULL</code> pointer means “do not assemble this”.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> assemble_t Kassembler<span class="op">);</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble_band<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> bandmat_t K<span class="op">);</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble_dense<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> densemat_t K<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For debugging small problems, it is also useful to have a routine to print out all the mesh arrays.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_print<span class="op">(</span>fem_t fe<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="implementation-1" class="level2">
<h2 class="anchored" data-anchor-id="implementation-1">Implementation</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb42"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate mesh object</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>fem_t fem_malloc<span class="op">(</span>mesh_t mesh<span class="op">,</span> <span class="dt">int</span> ndof<span class="op">)</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> mesh<span class="op">-&gt;</span>numnp<span class="op">;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    fem_t fe <span class="op">=</span> surely_malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> fem_t<span class="op">));</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>mesh    <span class="op">=</span> mesh<span class="op">;</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>etype   <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>ndof    <span class="op">=</span> ndof<span class="op">;</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>nactive <span class="op">=</span> numnp <span class="op">*</span> ndof<span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>U  <span class="op">=</span> double_calloc<span class="op">(</span>ndof <span class="op">*</span> numnp<span class="op">);</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>F  <span class="op">=</span> double_calloc<span class="op">(</span>ndof <span class="op">*</span> numnp<span class="op">);</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>id <span class="op">=</span> int_calloc<span class="op">(</span>ndof <span class="op">*</span> numnp<span class="op">);</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fe<span class="op">;</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a><span class="co">// Free mesh object</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_free<span class="op">(</span>fem_t fe<span class="op">)</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>fe<span class="op">-&gt;</span>id<span class="op">);</span></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>fe<span class="op">-&gt;</span>F<span class="op">);</span></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>fe<span class="op">-&gt;</span>U<span class="op">);</span></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>    mesh_free<span class="op">(</span>fe<span class="op">-&gt;</span>mesh<span class="op">);</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>fe<span class="op">);</span></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a><span class="co">// Initialize the id array and set nactive</span></span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fem_assign_ids<span class="op">(</span>fem_t fe<span class="op">)</span></span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numnp<span class="op">;</span></span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof <span class="op">=</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> id <span class="op">=</span> fe<span class="op">-&gt;</span>id<span class="op">;</span></span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> next_id <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>id<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a>                id<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">]</span> <span class="op">=</span> next_id<span class="op">++;</span></span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>nactive <span class="op">=</span> next_id<span class="op">;</span></span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> next_id<span class="op">;</span></span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a><span class="co">// Decrement U by du_red</span></span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_update_U<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> du_red<span class="op">)</span></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> U <span class="op">=</span> fe<span class="op">-&gt;</span>U<span class="op">;</span></span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> id   <span class="op">=</span> fe<span class="op">-&gt;</span>id<span class="op">;</span></span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof  <span class="op">=</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span></span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numnp<span class="op">;</span></span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>id<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a>                U<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">]</span> <span class="op">-=</span> du_red<span class="op">[</span>id<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">]];</span></span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a><span class="co">// Call the callback on each nodes (node position, force vector)</span></span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_set_load<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">void</span> <span class="op">(*</span>f<span class="op">)(</span><span class="dt">double</span><span class="op">*</span> x<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> fx<span class="op">))</span></span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d     <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">;</span></span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numnp<span class="op">;</span></span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof  <span class="op">=</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span></span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> X <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>X<span class="op">;</span></span>
<span id="cb42-64"><a href="#cb42-64" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> F <span class="op">=</span> fe<span class="op">-&gt;</span>F<span class="op">;</span></span>
<span id="cb42-65"><a href="#cb42-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb42-66"><a href="#cb42-66" aria-hidden="true" tabindex="-1"></a>        <span class="op">(*</span>f<span class="op">)(</span>X<span class="op">+</span>i<span class="op">*</span>d<span class="op">,</span> F<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">);</span></span>
<span id="cb42-67"><a href="#cb42-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-68"><a href="#cb42-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-69"><a href="#cb42-69" aria-hidden="true" tabindex="-1"></a><span class="co">// Assemble global residual and tangent stiffness (general)</span></span>
<span id="cb42-70"><a href="#cb42-70" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> assemble_t K<span class="op">)</span></span>
<span id="cb42-71"><a href="#cb42-71" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-72"><a href="#cb42-72" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numelt       <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numelt<span class="op">;</span></span>
<span id="cb42-73"><a href="#cb42-73" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen          <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>nen<span class="op">;</span></span>
<span id="cb42-74"><a href="#cb42-74" aria-hidden="true" tabindex="-1"></a>    element_t etype <span class="op">=</span> fe<span class="op">-&gt;</span>etype<span class="op">;</span></span>
<span id="cb42-75"><a href="#cb42-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-76"><a href="#cb42-76" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up local storage for element contributions</span></span>
<span id="cb42-77"><a href="#cb42-77" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> ids   <span class="op">=</span>     int_calloc<span class="op">(</span>nen<span class="op">);</span></span>
<span id="cb42-78"><a href="#cb42-78" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> Re <span class="op">=</span> R <span class="op">?</span> double_calloc<span class="op">(</span>nen<span class="op">)</span> <span class="op">:</span> NULL<span class="op">;</span></span>
<span id="cb42-79"><a href="#cb42-79" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> Ke <span class="op">=</span> K <span class="op">?</span> double_calloc<span class="op">(</span>nen<span class="op">*</span>nen<span class="op">)</span> <span class="op">:</span> NULL<span class="op">;</span></span>
<span id="cb42-80"><a href="#cb42-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-81"><a href="#cb42-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Clear storage for assembly</span></span>
<span id="cb42-82"><a href="#cb42-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>R<span class="op">)</span> memset<span class="op">(</span>R<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> fe<span class="op">-&gt;</span>nactive <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb42-83"><a href="#cb42-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>K<span class="op">)</span> assemble_clear<span class="op">(</span>K<span class="op">);</span></span>
<span id="cb42-84"><a href="#cb42-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-85"><a href="#cb42-85" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Assemble contributions</span></span>
<span id="cb42-86"><a href="#cb42-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numelt<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-87"><a href="#cb42-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-88"><a href="#cb42-88" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Get element contributions</span></span>
<span id="cb42-89"><a href="#cb42-89" aria-hidden="true" tabindex="-1"></a>        element_dR<span class="op">(</span>etype<span class="op">,</span> fe<span class="op">,</span> i<span class="op">,</span> Re<span class="op">,</span> Ke<span class="op">);</span></span>
<span id="cb42-90"><a href="#cb42-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-91"><a href="#cb42-91" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Figure out where to put them</span></span>
<span id="cb42-92"><a href="#cb42-92" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> elt <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>elt <span class="op">+</span> i<span class="op">*</span>nen<span class="op">;</span></span>
<span id="cb42-93"><a href="#cb42-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb42-94"><a href="#cb42-94" aria-hidden="true" tabindex="-1"></a>            ids<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> fe<span class="op">-&gt;</span>id<span class="op">[</span>elt<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb42-95"><a href="#cb42-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-96"><a href="#cb42-96" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Put them into the global vector/matrix</span></span>
<span id="cb42-97"><a href="#cb42-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>R<span class="op">)</span> assemble_vector<span class="op">(</span>R<span class="op">,</span> Re<span class="op">,</span> ids<span class="op">,</span> nen<span class="op">);</span></span>
<span id="cb42-98"><a href="#cb42-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>K<span class="op">)</span> assemble_add<span class="op">(</span>K<span class="op">,</span> Ke<span class="op">,</span> ids<span class="op">,</span> nen<span class="op">);</span></span>
<span id="cb42-99"><a href="#cb42-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-100"><a href="#cb42-100" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-101"><a href="#cb42-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-102"><a href="#cb42-102" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Free local storage</span></span>
<span id="cb42-103"><a href="#cb42-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Ke<span class="op">)</span> free<span class="op">(</span>Ke<span class="op">);</span></span>
<span id="cb42-104"><a href="#cb42-104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Re<span class="op">)</span> free<span class="op">(</span>Re<span class="op">);</span></span>
<span id="cb42-105"><a href="#cb42-105" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>ids<span class="op">);</span></span>
<span id="cb42-106"><a href="#cb42-106" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-107"><a href="#cb42-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-108"><a href="#cb42-108" aria-hidden="true" tabindex="-1"></a><span class="co">// Convenience function for assembling band matrix</span></span>
<span id="cb42-109"><a href="#cb42-109" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble_band<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> bandmat_t K<span class="op">)</span></span>
<span id="cb42-110"><a href="#cb42-110" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-111"><a href="#cb42-111" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-112"><a href="#cb42-112" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> assemble_t Kassembler<span class="op">;</span></span>
<span id="cb42-113"><a href="#cb42-113" aria-hidden="true" tabindex="-1"></a>        init_assemble_band<span class="op">(&amp;</span>Kassembler<span class="op">,</span> K<span class="op">);</span></span>
<span id="cb42-114"><a href="#cb42-114" aria-hidden="true" tabindex="-1"></a>        fem_assemble<span class="op">(</span>fe<span class="op">,</span> R<span class="op">,</span> <span class="op">&amp;</span>Kassembler<span class="op">);</span></span>
<span id="cb42-115"><a href="#cb42-115" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb42-116"><a href="#cb42-116" aria-hidden="true" tabindex="-1"></a>        fem_assemble<span class="op">(</span>fe<span class="op">,</span> R<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb42-117"><a href="#cb42-117" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-118"><a href="#cb42-118" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-119"><a href="#cb42-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-120"><a href="#cb42-120" aria-hidden="true" tabindex="-1"></a><span class="co">// Convenience function for assembling dense matrix</span></span>
<span id="cb42-121"><a href="#cb42-121" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble_dense<span class="op">(</span>fem_t fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> densemat_t K<span class="op">)</span></span>
<span id="cb42-122"><a href="#cb42-122" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-123"><a href="#cb42-123" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-124"><a href="#cb42-124" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> assemble_t Kassembler<span class="op">;</span></span>
<span id="cb42-125"><a href="#cb42-125" aria-hidden="true" tabindex="-1"></a>        init_assemble_dense<span class="op">(&amp;</span>Kassembler<span class="op">,</span> K<span class="op">);</span></span>
<span id="cb42-126"><a href="#cb42-126" aria-hidden="true" tabindex="-1"></a>        fem_assemble<span class="op">(</span>fe<span class="op">,</span> R<span class="op">,</span> <span class="op">&amp;</span>Kassembler<span class="op">);</span></span>
<span id="cb42-127"><a href="#cb42-127" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb42-128"><a href="#cb42-128" aria-hidden="true" tabindex="-1"></a>        fem_assemble<span class="op">(</span>fe<span class="op">,</span> R<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb42-129"><a href="#cb42-129" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-130"><a href="#cb42-130" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-131"><a href="#cb42-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-132"><a href="#cb42-132" aria-hidden="true" tabindex="-1"></a><span class="co">// Print mesh state</span></span>
<span id="cb42-133"><a href="#cb42-133" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_print<span class="op">(</span>fem_t fe<span class="op">)</span></span>
<span id="cb42-134"><a href="#cb42-134" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-135"><a href="#cb42-135" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Nodal information:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb42-136"><a href="#cb42-136" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"       ID "</span><span class="op">);</span></span>
<span id="cb42-137"><a href="#cb42-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> printf<span class="op">(</span><span class="st">"     X</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb42-138"><a href="#cb42-138" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span>   printf<span class="op">(</span><span class="st">"     U</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb42-139"><a href="#cb42-139" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span>   printf<span class="op">(</span><span class="st">"     F</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb42-140"><a href="#cb42-140" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb42-141"><a href="#cb42-141" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-142"><a href="#cb42-142" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%3d</span><span class="st"> : </span><span class="sc">% 3d</span><span class="st"> "</span><span class="op">,</span> i<span class="op">,</span> fe<span class="op">-&gt;</span>id<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb42-143"><a href="#cb42-143" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb42-144"><a href="#cb42-144" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">" </span><span class="sc">%6.2g</span><span class="st">"</span><span class="op">,</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>X<span class="op">[</span>j<span class="op">+</span>fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">*</span>i<span class="op">]);</span></span>
<span id="cb42-145"><a href="#cb42-145" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb42-146"><a href="#cb42-146" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">" </span><span class="sc">% 6.2g</span><span class="st">"</span><span class="op">,</span> fe<span class="op">-&gt;</span>U<span class="op">[</span>j<span class="op">+</span>fe<span class="op">-&gt;</span>ndof<span class="op">*</span>i<span class="op">]);</span></span>
<span id="cb42-147"><a href="#cb42-147" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb42-148"><a href="#cb42-148" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">" </span><span class="sc">% 6.2g</span><span class="st">"</span><span class="op">,</span> fe<span class="op">-&gt;</span>F<span class="op">[</span>j<span class="op">+</span>fe<span class="op">-&gt;</span>ndof<span class="op">*</span>i<span class="op">]);</span></span>
<span id="cb42-149"><a href="#cb42-149" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb42-150"><a href="#cb42-150" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-151"><a href="#cb42-151" aria-hidden="true" tabindex="-1"></a>    mesh_print_elt<span class="op">(</span>fe<span class="op">-&gt;</span>mesh<span class="op">);</span></span>
<span id="cb42-152"><a href="#cb42-152" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="elements" class="level1">
<h1>Elements</h1>
<p>Abstractly, for steady-state problems, we are finding <span class="math inline">\(u(x) = \sum_j N_j(x) u_j\)</span> via an equation <span class="math display">\[
  R(u, N_i) = 0
\]</span> for all shape functions <span class="math inline">\(N_i\)</span> that are not associated with essential boundary conditions. The element routines compute the contribution of one element to the residual <span class="math inline">\(R\)</span> and to the tangent <span class="math inline">\(\partial R/\partial u_j\)</span>.</p>
<p>Different types of equations demand different types of elements. Even for a single type of element, we may depend on things like PDE coefficients or choices of material parameters (as well as implementation details like the quadrature rule used for computing integrals). An <code>element_t</code> object type keeps all this information together. The <code>element_t</code> data type should be thought of as representing a <em>type</em> of element, and not one specific element; usually many elements share fundamentally the same data, differing only in which nodes they involve. In the language of design patterns, this is an example of a “flyweight” pattern.</p>
<p>The main interface for an element is a method</p>
<pre><code>dR(p, fe, eltid, Re, Ke)</code></pre>
<p>where <code>p</code> is context data for the element type, <code>fe</code> is a finite element mesh data structure, <code>eltid</code> is the index of the element in the mesh, and <code>Re</code> and <code>Ke</code> are pointers to storage for the element residual and tangent matrix contributions. Either <code>Re</code> or <code>Ke</code> can be null, indicating that we don’t need that output.</p>
<p>We also provide a destructor method (<code>free</code>) for releasing resources used by the <code>element_t</code> instance.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb44"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Element type interface</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> element_t <span class="op">{</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>p<span class="op">;</span> <span class="co">// Context pointer</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>dR<span class="op">)(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> <span class="kw">struct</span> fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>              <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">);</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>free<span class="op">)(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">);</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="op">*</span>element_t<span class="op">;</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Wrappers for calling the dR and free method</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> element_dR<span class="op">(</span>element_t e<span class="op">,</span> <span class="kw">struct</span> fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">);</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> element_free<span class="op">(</span>element_t e<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Write now, we only have one element type, corresponding to a 1D Poisson problem, written in weak form as <span class="math display">\[
R(u, N_i) =
\int_{\Omega} \left(
\nabla N_i(x) \cdot \nabla u(x) -
N_i(x) f(x) \right) \, d\Omega(x).
\]</span> There are no PDE coefficients or other special parameters to keep track of for this element tyle.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>element_t malloc_poisson1d_element<span class="op">(</span><span class="dt">void</span><span class="op">);</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>element_t malloc_poisson2d_element<span class="op">(</span><span class="dt">void</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="method-dispatch-1" class="level2">
<h2 class="anchored" data-anchor-id="method-dispatch-1">Method dispatch</h2>
<p>As usual for when we do OOP in C, we have dispatch functions that essentially trampoline a call to the appropriate function pointer in an element object’s dispatch table.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb46"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Call element dR method</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> element_dR<span class="op">(</span>element_t e<span class="op">,</span> fem_t fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>                <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">)</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>e<span class="op">-&gt;</span>dR<span class="op">))(</span>e<span class="op">-&gt;</span>p<span class="op">,</span> fe<span class="op">,</span> eltid<span class="op">,</span> Re<span class="op">,</span> Ke<span class="op">);</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Call element free</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> element_free<span class="op">(</span>element_t e<span class="op">)</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>e<span class="op">-&gt;</span>free<span class="op">))(</span>e<span class="op">-&gt;</span>p<span class="op">);</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>We write our Poisson interface to illustrate the general pattern, even though we could in principle simplify it (because we are not carrying around any element parameters in this case). The internal wiring is:</p>
<ul>
<li>Element type data is stored in a structure like <code>poisson1d_elt_t</code>.</li>
<li>One field of the specific element is an <code>element_t</code> containing the methods table for the element.</li>
<li>The data pointer in the <code>element_t</code> field points back to the containing struct (the <code>poisson1d_elt_t</code> in this case).</li>
</ul>
<p>Externally, we always pass around <code>element_t</code> pointers. Internally, we always use the more specific <code>poisson1d_elt_t</code> from the <code>element_t</code> data pointer.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb47"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Poisson element type data structure</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> poisson_elt_t <span class="op">{</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Material parameters, etc go here in more complex cases</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> element_t e<span class="op">;</span> <span class="co">// For dispatch table</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="op">*</span>poisson_elt_t<span class="op">;</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare methods for 1D and 2D Poisson element types</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> poisson1d_elt_dR<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> fem_t fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>                             <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">);</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> poisson2d_elt_dR<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> fem_t fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>                             <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">);</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> simple_elt_free<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">);</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate a 1D Poisson element type</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>element_t malloc_poisson1d_element<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    poisson_elt_t le <span class="op">=</span> <span class="op">(</span>poisson_elt_t<span class="op">)</span> surely_malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> poisson_elt_t<span class="op">));</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>p <span class="op">=</span> le<span class="op">;</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>dR <span class="op">=</span> poisson1d_elt_dR<span class="op">;</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>free <span class="op">=</span> simple_elt_free<span class="op">;</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;(</span>le<span class="op">-&gt;</span>e<span class="op">);</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate a 2D Poisson element type</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>element_t malloc_poisson2d_element<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>    poisson_elt_t le <span class="op">=</span> <span class="op">(</span>poisson_elt_t<span class="op">)</span> surely_malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> poisson_elt_t<span class="op">));</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>p <span class="op">=</span> le<span class="op">;</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>dR <span class="op">=</span> poisson2d_elt_dR<span class="op">;</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>free <span class="op">=</span> simple_elt_free<span class="op">;</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;(</span>le<span class="op">-&gt;</span>e<span class="op">);</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a><span class="co">// Free a Poisson element type</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> simple_elt_free<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">)</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="d-poisson-element" class="level2">
<h2 class="anchored" data-anchor-id="d-poisson-element">1D Poisson element</h2>
<p>The 1D Poisson element <code>dR</code> routine computes the local residual terms <span class="math display">\[
R^e(u, N^e_i(x)) =
\int_{\Omega_e}
\left( \nabla N^e_i(x) \cdot \nabla u(x) - N^e_i(x) f(x) \right) \,
d\Omega(x).
\]</span> The functions <span class="math inline">\(u(x)\)</span> is represented on <span class="math inline">\(\Omega_e\)</span> in terms of the element shape functions <span class="math display">\[
  u(x) = \sum_i N^e_i(x) u_i
\]</span> and similarly for <span class="math inline">\(f(x)\)</span>. The tangent matrix has entries <span class="math display">\[
\partial ( R^e(u(x), N^e_i(x)) )/\partial u_j =
\int_{\Omega_e} \nabla N^e_i(x) \cdot \nabla N^e_j(x) \, d\Omega(x).
\]</span> We organize the computation of the integrals (both for the residual vector and the tangent matrix) as an outer loop over quadrature nodes and inner loops over the shape function indices at the quadrature node.</p>
<p>We compute integrals using <em>mapped</em> quadrature: the locations of quadrature points in element reference domains are mapped to the element spatial domain, and the weights are multiplied by the Jacobian determinant for this computation.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb48"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> poisson1d_elt_dR<span class="op">(</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> p<span class="op">,</span>                   <span class="co">// Context pointer (not used)</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    fem_t fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span>      <span class="co">// Mesh and element ID in mesh</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">)</span>    <span class="co">// Outputs: element residual and tangent</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen  <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>nen<span class="op">;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof <span class="op">=</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> degree <span class="op">=</span> nen<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nquad <span class="op">=</span> degree<span class="op">;</span> <span class="co">// Would need one more for mass matrix...</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> elt <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>elt <span class="op">+</span> eltid<span class="op">*</span>nen<span class="op">;</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Clear element storage</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Re<span class="op">)</span> memset<span class="op">(</span>Re<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nen<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Ke<span class="op">)</span> memset<span class="op">(</span>Ke<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nen<span class="op">*</span>nen<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> nquad<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Get information about quadrature point (spatial)</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> N<span class="op">[</span><span class="dv">4</span><span class="op">];</span>  <span class="co">// Storage for shape functions</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> dN<span class="op">[</span><span class="dv">4</span><span class="op">];</span> <span class="co">// Storage for shape derivatives</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> x  <span class="op">=</span> gauss_point<span class="op">(</span>k<span class="op">,</span> nquad<span class="op">);</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> wt <span class="op">=</span> gauss_weight<span class="op">(</span>k<span class="op">,</span> nquad<span class="op">);</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>        wt <span class="op">*=</span> mesh_shapes<span class="op">(</span>fe<span class="op">-&gt;</span>mesh<span class="op">,</span> eltid<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> N<span class="op">,</span> dN<span class="op">);</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add residual</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>Re<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> du <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> fx <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span><span class="op">*</span> U <span class="op">=</span> fe<span class="op">-&gt;</span>U<span class="op">;</span></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span><span class="op">*</span> F <span class="op">=</span> fe<span class="op">-&gt;</span>F<span class="op">;</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>                du <span class="op">+=</span> dN<span class="op">[</span>j<span class="op">]*</span>U<span class="op">[</span>ndof<span class="op">*</span>elt<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>                fx <span class="op">+=</span> N<span class="op">[</span>j<span class="op">]*</span>F<span class="op">[</span>ndof<span class="op">*</span>elt<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>                Re<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> <span class="op">(</span>dN<span class="op">[</span>i<span class="op">]*</span>du <span class="op">-</span> N<span class="op">[</span>i<span class="op">]*</span>fx<span class="op">)</span> <span class="op">*</span> wt<span class="op">;</span></span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add tangent stiffness</span></span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>Ke<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>                    Ke<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>nen<span class="op">]</span> <span class="op">+=</span> dN<span class="op">[</span>i<span class="op">]*</span>dN<span class="op">[</span>j<span class="op">]</span> <span class="op">*</span> wt<span class="op">;</span></span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="poisson-elements-in-2d" class="level2">
<h2 class="anchored" data-anchor-id="poisson-elements-in-2d">Poisson elements in 2D</h2>
<p>The 2D Poisson elements are very similar to the 1D case. As we wrote the formulas in a dimension-independent way in the documentation of the 1D case, we will not repeat ourselves here. The one thing that is a little different is that we will do a little more work to get an appropriate quadrature rule.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb49"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">int</span> get_quad2d<span class="op">(</span>shapes_t shapefn<span class="op">,</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">void</span> <span class="op">(**</span>quad_pt<span class="op">)(</span><span class="dt">double</span><span class="op">*,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">),</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">double</span> <span class="op">(**</span>quad_wt<span class="op">)(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">))</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>shapefn <span class="op">==</span> shapes2dP1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>quad_pt <span class="op">=</span> gauss2d_point<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>quad_wt <span class="op">=</span> gauss2d_weight<span class="op">;</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>shapefn <span class="op">==</span> shapes2dP2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>quad_pt <span class="op">=</span> gauss2d_point<span class="op">;</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>quad_wt <span class="op">=</span> gauss2d_weight<span class="op">;</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>shapefn <span class="op">==</span> shapes2dS2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>quad_pt <span class="op">=</span> gauss2d_point<span class="op">;</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>quad_wt <span class="op">=</span> gauss2d_weight<span class="op">;</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>shapefn <span class="op">==</span> shapes2dT1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>quad_pt <span class="op">=</span> hughes_point<span class="op">;</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>quad_wt <span class="op">=</span> hughes_weight<span class="op">;</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>        assert<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="co">/* unreachable */</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a><span class="co">/*static*/</span> <span class="dt">void</span> poisson2d_elt_dR<span class="op">(</span></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> p<span class="op">,</span>                   <span class="co">// Context pointer (not used)</span></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>    fem_t fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span>      <span class="co">// Mesh and element ID in mesh</span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">)</span>    <span class="co">// Outputs: element residual and tangent</span></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen  <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>nen<span class="op">;</span></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof <span class="op">=</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>quad_pt<span class="op">)(</span><span class="dt">double</span><span class="op">*,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">);</span></span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="op">(*</span>quad_wt<span class="op">)(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">);</span></span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nquad <span class="op">=</span> get_quad2d<span class="op">(</span>fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>shape<span class="op">,</span> <span class="op">&amp;</span>quad_pt<span class="op">,</span> <span class="op">&amp;</span>quad_wt<span class="op">);</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> elt <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>elt <span class="op">+</span> eltid<span class="op">*</span>nen<span class="op">;</span></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Clear element storage</span></span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Re<span class="op">)</span> memset<span class="op">(</span>Re<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nen<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Ke<span class="op">)</span> memset<span class="op">(</span>Ke<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nen<span class="op">*</span>nen<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> nquad<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Get information about quadrature point (spatial)</span></span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> N<span class="op">[</span><span class="dv">4</span><span class="op">];</span>    <span class="co">// Storage for shape functions</span></span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> dN<span class="op">[</span><span class="dv">4</span><span class="op">*</span><span class="dv">2</span><span class="op">];</span> <span class="co">// Storage for shape derivatives</span></span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> x<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">(*</span>quad_pt<span class="op">)(</span>x<span class="op">,</span> k<span class="op">,</span> nquad<span class="op">);</span></span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> wt <span class="op">=</span> <span class="op">(*</span>quad_wt<span class="op">)(</span>k<span class="op">,</span> nquad<span class="op">);</span></span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> J  <span class="op">=</span> mesh_shapes<span class="op">(</span>fe<span class="op">-&gt;</span>mesh<span class="op">,</span> eltid<span class="op">,</span> x<span class="op">,</span> N<span class="op">,</span> dN<span class="op">);</span></span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a>        wt <span class="op">*=</span> J<span class="op">;</span></span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-53"><a href="#cb49-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add residual</span></span>
<span id="cb49-54"><a href="#cb49-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>Re<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-55"><a href="#cb49-55" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> du<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">};</span></span>
<span id="cb49-56"><a href="#cb49-56" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> fx <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb49-57"><a href="#cb49-57" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span><span class="op">*</span> U <span class="op">=</span> fe<span class="op">-&gt;</span>U<span class="op">;</span></span>
<span id="cb49-58"><a href="#cb49-58" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span><span class="op">*</span> F <span class="op">=</span> fe<span class="op">-&gt;</span>F<span class="op">;</span></span>
<span id="cb49-59"><a href="#cb49-59" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-60"><a href="#cb49-60" aria-hidden="true" tabindex="-1"></a>                du<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> U<span class="op">[</span>ndof<span class="op">*</span>elt<span class="op">[</span>j<span class="op">]]*</span>dN<span class="op">[</span>j<span class="op">+</span><span class="dv">0</span><span class="op">*</span>nen<span class="op">];</span></span>
<span id="cb49-61"><a href="#cb49-61" aria-hidden="true" tabindex="-1"></a>                du<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">+=</span> U<span class="op">[</span>ndof<span class="op">*</span>elt<span class="op">[</span>j<span class="op">]]*</span>dN<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">*</span>nen<span class="op">];</span></span>
<span id="cb49-62"><a href="#cb49-62" aria-hidden="true" tabindex="-1"></a>                fx <span class="op">+=</span> N<span class="op">[</span>j<span class="op">]*</span>F<span class="op">[</span>ndof<span class="op">*</span>elt<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb49-63"><a href="#cb49-63" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb49-64"><a href="#cb49-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb49-65"><a href="#cb49-65" aria-hidden="true" tabindex="-1"></a>                Re<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> <span class="op">(</span>dN<span class="op">[</span>i<span class="op">+</span><span class="dv">0</span><span class="op">*</span>nen<span class="op">]*</span>du<span class="op">[</span><span class="dv">0</span><span class="op">]+</span>dN<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">*</span>nen<span class="op">]*</span>du<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> N<span class="op">[</span>i<span class="op">]*</span>fx<span class="op">)</span> <span class="op">*</span> wt<span class="op">;</span></span>
<span id="cb49-66"><a href="#cb49-66" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-67"><a href="#cb49-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-68"><a href="#cb49-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add tangent stiffness</span></span>
<span id="cb49-69"><a href="#cb49-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>Ke<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-70"><a href="#cb49-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb49-71"><a href="#cb49-71" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb49-72"><a href="#cb49-72" aria-hidden="true" tabindex="-1"></a>                    Ke<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>nen<span class="op">]</span> <span class="op">+=</span> <span class="op">(</span>dN<span class="op">[</span>i<span class="op">]*</span>dN<span class="op">[</span>j<span class="op">]+</span>dN<span class="op">[</span>i<span class="op">+</span>nen<span class="op">]*</span>dN<span class="op">[</span>j<span class="op">+</span>nen<span class="op">])</span> <span class="op">*</span> wt<span class="op">;</span></span>
<span id="cb49-73"><a href="#cb49-73" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-74"><a href="#cb49-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-75"><a href="#cb49-75" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>