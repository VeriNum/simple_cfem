<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David Bindel">

<title>Simple 1D FEM in C</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#vector-and-matrix-conveniences" id="toc-vector-and-matrix-conveniences" class="nav-link active" data-scroll-target="#vector-and-matrix-conveniences">Vector and matrix conveniences</a>
  <ul class="collapse">
  <li><a href="#memory-management" id="toc-memory-management" class="nav-link" data-scroll-target="#memory-management">Memory management</a></li>
  <li><a href="#io" id="toc-io" class="nav-link" data-scroll-target="#io">I/O</a></li>
  <li><a href="#cholesky-factorization" id="toc-cholesky-factorization" class="nav-link" data-scroll-target="#cholesky-factorization">Cholesky factorization</a></li>
  <li><a href="#norm-computations" id="toc-norm-computations" class="nav-link" data-scroll-target="#norm-computations">Norm computations</a></li>
  </ul></li>
  <li><a href="#band-matrix-operations" id="toc-band-matrix-operations" class="nav-link" data-scroll-target="#band-matrix-operations">Band matrix operations</a>
  <ul class="collapse">
  <li><a href="#band-matrix-construction" id="toc-band-matrix-construction" class="nav-link" data-scroll-target="#band-matrix-construction">Band matrix construction</a></li>
  <li><a href="#printing-a-band-matrix" id="toc-printing-a-band-matrix" class="nav-link" data-scroll-target="#printing-a-band-matrix">Printing a band matrix</a></li>
  <li><a href="#band-cholesky-and-triangular-solves" id="toc-band-cholesky-and-triangular-solves" class="nav-link" data-scroll-target="#band-cholesky-and-triangular-solves">Band Cholesky and triangular solves</a></li>
  </ul></li>
  <li><a href="#shape-functions" id="toc-shape-functions" class="nav-link" data-scroll-target="#shape-functions">Shape functions</a></li>
  <li><a href="#mesh-geometry" id="toc-mesh-geometry" class="nav-link" data-scroll-target="#mesh-geometry">Mesh geometry</a></li>
  <li><a href="#gaussian-legendre-quadrature-rules" id="toc-gaussian-legendre-quadrature-rules" class="nav-link" data-scroll-target="#gaussian-legendre-quadrature-rules">Gaussian-Legendre quadrature rules</a></li>
  <li><a href="#assembly" id="toc-assembly" class="nav-link" data-scroll-target="#assembly">Assembly</a>
  <ul class="collapse">
  <li><a href="#matrix-assembler-interface" id="toc-matrix-assembler-interface" class="nav-link" data-scroll-target="#matrix-assembler-interface">Matrix assembler interface</a></li>
  <li><a href="#vector-assembly-interface" id="toc-vector-assembly-interface" class="nav-link" data-scroll-target="#vector-assembly-interface">Vector assembly interface</a></li>
  <li><a href="#method-dispatch" id="toc-method-dispatch" class="nav-link" data-scroll-target="#method-dispatch">Method dispatch</a></li>
  <li><a href="#matrix-assembly-loops" id="toc-matrix-assembly-loops" class="nav-link" data-scroll-target="#matrix-assembly-loops">Matrix assembly loops</a></li>
  <li><a href="#clearing-storage" id="toc-clearing-storage" class="nav-link" data-scroll-target="#clearing-storage">Clearing storage</a></li>
  <li><a href="#vector-assembly" id="toc-vector-assembly" class="nav-link" data-scroll-target="#vector-assembly">Vector assembly</a></li>
  </ul></li>
  <li><a href="#finite-element-mesh" id="toc-finite-element-mesh" class="nav-link" data-scroll-target="#finite-element-mesh">Finite element mesh</a>
  <ul class="collapse">
  <li><a href="#mesh-operations" id="toc-mesh-operations" class="nav-link" data-scroll-target="#mesh-operations">Mesh operations</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  </ul></li>
  <li><a href="#elements" id="toc-elements" class="nav-link" data-scroll-target="#elements">Elements</a>
  <ul class="collapse">
  <li><a href="#method-dispatch-1" id="toc-method-dispatch-1" class="nav-link" data-scroll-target="#method-dispatch-1">Method dispatch</a></li>
  <li><a href="#mapped-quadrature" id="toc-mapped-quadrature" class="nav-link" data-scroll-target="#mapped-quadrature">Mapped quadrature</a></li>
  <li><a href="#d-poisson-element" id="toc-d-poisson-element" class="nav-link" data-scroll-target="#d-poisson-element">1D Poisson element</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simple 1D FEM in C</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David Bindel </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="vector-and-matrix-conveniences" class="level1">
<h1>Vector and matrix conveniences</h1>
<p>C does not make it particularly easy to work with matrices and vectors. Part of the difficulty is the lack of a convenient place to store size information. We work around this by defining a data structure (which we will refer to as a <code>vecmat_t</code>, though this type is never explicitly used in our code) consisting of dimension data followed by a data array. We generally pass the object around with a pointer to the start of the data (in standard C style), only backing up in memory to access size information when we need it.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> vecmat_head_t <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m<span class="op">,</span> n<span class="op">;</span>       <span class="co">// Row and column counts</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> data<span class="op">[</span><span class="dv">1</span><span class="op">];</span> <span class="co">// Start of data array</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> vecmat_head_t<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Get header information by backing up from data pointer</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>vecmat_head_t<span class="op">*</span> vecmat<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Create and free </span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> malloc_vecmat<span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free_vecmat<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Clear storage</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vecmat_clear<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Print array (assumes column major order)</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vecmat_print<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">// Cholesky factorization and solve (uses only upper triangular)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vecmat_cfactor<span class="op">(</span><span class="dt">double</span><span class="op">*</span> A<span class="op">);</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vecmat_csolve<span class="op">(</span><span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">// Squared norm and norm computations</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> vecmat_norm2<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> vecmat_norm<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="memory-management" class="level2">
<h2 class="anchored" data-anchor-id="memory-management">Memory management</h2>
<p>We usually refer to a <code>vecmat_t</code> with a pointer to the (extended) <code>data</code> array whose start is declared in the <code>vecmat_head_t</code> structure. The <code>vecmat</code> function takes a double precision pointer to such a data field and backs up to get a pointer to the struct.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>vecmat_head_t<span class="op">*</span> vecmat<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t dummy<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> p <span class="op">=</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)</span> data <span class="op">+</span> <span class="op">((</span><span class="dt">void</span><span class="op">*)</span> <span class="op">&amp;</span>dummy <span class="op">-</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)</span> dummy<span class="op">.</span>data<span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>vecmat_head_t<span class="op">*)</span> p<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>malloc_vecmat</code> function allocates space for the head structure (which contains the first entry in the data array) along with space for the remainder of the <code>m*n</code> double precision numbers in the data array. Because we want to be able to pass <code>vecmat_t</code> data into C functions that take plain pointers, we don’t return the pointer to the head structure, but the pointer to the data field.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> malloc_vecmat<span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> h <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>vecmat_head_t<span class="op">)</span> <span class="op">+</span> <span class="op">(</span>m<span class="op">*</span>n<span class="op">-</span><span class="dv">1</span><span class="op">)*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    h<span class="op">-&gt;</span>m <span class="op">=</span> m<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    h<span class="op">-&gt;</span>n <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> h<span class="op">-&gt;</span>data<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free_vecmat<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>vecmat<span class="op">(</span>data<span class="op">));</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vecmat_clear<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">)</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> vm <span class="op">=</span> vecmat<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> vm<span class="op">-&gt;</span>m<span class="op">,</span> n <span class="op">=</span> vm<span class="op">-&gt;</span>n<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>data<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> m<span class="op">*</span>n <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="io" class="level2">
<h2 class="anchored" data-anchor-id="io">I/O</h2>
<p>We provide a print routines as an aid to debugging. In order to make sure that modest size matrices can be printed on the screen in a digestible matter, we only print the first couple digits in each entry. Note that we assume column major layout throughout.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vecmat_print<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> vm <span class="op">=</span> vecmat<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> vm<span class="op">-&gt;</span>m<span class="op">,</span> n <span class="op">=</span> vm<span class="op">-&gt;</span>n<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> A <span class="op">=</span> vm<span class="op">-&gt;</span>data<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">-by-</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> m<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">" </span><span class="sc">% 6.2g</span><span class="st">"</span><span class="op">,</span> A<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>m<span class="op">]);</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="cholesky-factorization" class="level2">
<h2 class="anchored" data-anchor-id="cholesky-factorization">Cholesky factorization</h2>
<p>For our finite element code, we will largely work with SPD matrices for which a Cholesky solve is appropriate. On input, we assume a column major representation in which the upper triangle represents the upper triangle of an SPD matrix; the lower triangle is ignored. On output, the upper triangle of the matrix argument is overwritten by the Cholesky factor. We will error out if we encounter a negative diagonal (in violation of the assumed positive definiteness).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vecmat_cfactor<span class="op">(</span><span class="dt">double</span><span class="op">*</span> A<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> head <span class="op">=</span> vecmat<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> head<span class="op">-&gt;</span>m<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Compute kth diagonal element</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> akk <span class="op">=</span> A<span class="op">[</span>k<span class="op">+</span>n<span class="op">*</span>k<span class="op">];</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        assert<span class="op">(</span>akk <span class="op">&gt;=</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> rkk <span class="op">=</span> sqrt<span class="op">(</span>akk<span class="op">);</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        A<span class="op">[</span>k<span class="op">+</span>n<span class="op">*</span>k<span class="op">]</span> <span class="op">=</span> rkk<span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Scale across the row</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            A<span class="op">[</span>k<span class="op">+</span>n<span class="op">*</span>j<span class="op">]</span> <span class="op">/=</span> rkk<span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Apply the Schur complement update</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> j<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>                A<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>n<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">+</span>i<span class="op">*</span>n<span class="op">]*</span>A<span class="op">[</span>k<span class="op">+</span>j<span class="op">*</span>n<span class="op">];</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>vecmat_csolve(R, x)</code> function assumes a Cholesky factor in the upper triangle of input argument <code>R</code>; the argument <code>x</code> is the right-hand side vector <span class="math inline">\(b\)</span> on input, and the solution vector <span class="math inline">\(x\)</span> on output.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> vecmat_csolve<span class="op">(</span><span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> head <span class="op">=</span> vecmat<span class="op">(</span>R<span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> head<span class="op">-&gt;</span>m<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Forward substitution</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> bi <span class="op">=</span> x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            bi <span class="op">-=</span> R<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>n<span class="op">]*</span>x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> bi<span class="op">/</span>R<span class="op">[</span>i<span class="op">+</span>i<span class="op">*</span>n<span class="op">];</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Backward substitution</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n<span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> yi <span class="op">=</span> x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            yi <span class="op">-=</span> R<span class="op">[</span>i<span class="op">+</span>n<span class="op">*</span>j<span class="op">]*</span>x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> yi<span class="op">/</span>R<span class="op">[</span>i<span class="op">+</span>i<span class="op">*</span>n<span class="op">];</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="norm-computations" class="level2">
<h2 class="anchored" data-anchor-id="norm-computations">Norm computations</h2>
<p>Just for checking on residuals and errors, it’s convenient to have some functions for computing the squared Euclidean norm and the norm of a vector. We assume that things are sufficiently well scaled that we don’t need to worry about over/underflow.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> vecmat_norm2<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> vm <span class="op">=</span> vecmat<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> vm<span class="op">-&gt;</span>m<span class="op">,</span> n <span class="op">=</span> vm<span class="op">-&gt;</span>n<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> A <span class="op">=</span> vm<span class="op">-&gt;</span>data<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> result <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> Aij <span class="op">=</span> A<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>m<span class="op">];</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            result <span class="op">+=</span> Aij<span class="op">*</span>Aij<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>result<span class="op">);</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> vecmat_norm<span class="op">(</span><span class="dt">double</span><span class="op">*</span> data<span class="op">)</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>vecmat_norm2<span class="op">(</span>data<span class="op">));</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="band-matrix-operations" class="level1">
<h1>Band matrix operations</h1>
<p>We store symmetric band matrices using the LAPACK symmetric band format (see, e.g.&nbsp;<code>DSBTRF</code>). This is a packed storage format in which a symmetric matrix with <code>b</code> nonzero diagonals off th main diagonal in either direction is stored one diagonal at a time. That is, the dense matrix entry <code>A[i,j]</code> (column major) is stored in a packed array <code>P</code> of size <code>n</code>-by-<code>b+1</code> at location <code>P[j,d]</code>, where <code>d = j-i</code> is the diagonal number. The leading <code>d</code> entries of diagonal <code>d</code> are not used (but we don’t try to eliminate them in the interest of keeping our indexing simple). Because we are interested in symmetric matrices, we only need to explicitly store the upper triangle (<code>d &gt;= 0</code>).</p>
<p>Because the storage format is essentially a dense <code>n</code>-by-<code>b+1</code> array, we will not introduce a totally new data structure for the band matrix; the <code>vecmat_t</code> storage container for dense matrices that we introduced before works well enough.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate a new bandmat (and maybe populate from a dense matrix)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> malloc_bandmat<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> b<span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> dense_to_band<span class="op">(</span><span class="dt">double</span><span class="op">*</span> A<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> bw<span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Print a bandmat</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bandmat_print<span class="op">(</span><span class="dt">double</span><span class="op">*</span> PA<span class="op">);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Cholesky and linear solve with Cholesky</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bandmat_factor<span class="op">(</span><span class="dt">double</span><span class="op">*</span> PA<span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bandmat_solve<span class="op">(</span><span class="dt">double</span><span class="op">*</span> PR<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="band-matrix-construction" class="level2">
<h2 class="anchored" data-anchor-id="band-matrix-construction">Band matrix construction</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate a band matrix</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> malloc_bandmat<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> malloc_vecmat<span class="op">(</span>n<span class="op">,</span> b<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Convert dense n-by-n A to band matrix P with bandwidth bw</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> dense_to_band<span class="op">(</span><span class="dt">double</span><span class="op">*</span> A<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> bw<span class="op">)</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> P <span class="op">=</span> malloc_bandmat<span class="op">(</span>n<span class="op">,</span> bw<span class="op">);</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> bw<span class="op">;</span> <span class="op">++</span>d<span class="op">)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> d<span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> j<span class="op">-</span>d<span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            P<span class="op">[</span>j<span class="op">+</span>d<span class="op">*</span>n<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>n<span class="op">];</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="printing-a-band-matrix" class="level2">
<h2 class="anchored" data-anchor-id="printing-a-band-matrix">Printing a band matrix</h2>
<p>When printing a band matrix, we usually print just the structural nonzeros. Unless the matrix is very small, trying to introduce spaces or dots for structural zeros usually just makes the output too big to fit on a screen; hence, we will <em>almost</em> just print the underlying <code>n</code>-by-<code>b+1</code> data array. The only difference is that we will not bother to print out the “don’t care” values that are at the start of the superdiagonal representations (since they will be garbage unless we zeroed them out, and anyway – we don’t care about them).</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Print band format array</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bandmat_print<span class="op">(</span><span class="dt">double</span><span class="op">*</span> PA<span class="op">)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> head <span class="op">=</span> vecmat<span class="op">(</span>PA<span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> head<span class="op">-&gt;</span>m<span class="op">,</span> bw <span class="op">=</span> head<span class="op">-&gt;</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> bw <span class="op">&amp;&amp;</span> d <span class="op">&lt;=</span> i<span class="op">;</span> <span class="op">++</span>d<span class="op">)</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"  </span><span class="sc">% 6.3g</span><span class="st">"</span><span class="op">,</span> PA<span class="op">[</span>i<span class="op">+</span>d<span class="op">*</span>n<span class="op">]);</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="band-cholesky-and-triangular-solves" class="level2">
<h2 class="anchored" data-anchor-id="band-cholesky-and-triangular-solves">Band Cholesky and triangular solves</h2>
<p>When computing a Cholesky factorization of a band matrix, the Schur complement update step only affects elements that were already structural nonzeros. Hence, Cholesky factorization of a band matrix can be done purely within the band data structure. The algorithm is essentially identical to the ordinary Cholesky factorization, except with indexing appropriate to the packed data structure. As with the dense Cholesky implementation in <code>vecmat_t</code>, we only ever reference the upper triangle of the matrix, and we overwrite the input arrays (representing the upper triangle of a symmetric input) by the output (representing an upper triangular Cholesky factor). Also as with dense Cholesky, we will error out if we encounter a negative diagonal in a Schur complement (violating the assumption of positive definiteness).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bandmat_factor<span class="op">(</span><span class="dt">double</span><span class="op">*</span> PA<span class="op">)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> head <span class="op">=</span> vecmat<span class="op">(</span>PA<span class="op">);</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> head<span class="op">-&gt;</span>m<span class="op">,</span> bw<span class="op">=</span>head<span class="op">-&gt;</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Compute kth diagonal element</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        assert<span class="op">(</span>PA<span class="op">[</span>k<span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        PA<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> sqrt<span class="op">(</span>PA<span class="op">[</span>k<span class="op">]);</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Scale across the row</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> k<span class="op">+</span>bw<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            PA<span class="op">[</span>j<span class="op">+</span>n<span class="op">*(</span>j<span class="op">-</span>k<span class="op">)]</span> <span class="op">/=</span> PA<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Apply the Schur complement update</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> k<span class="op">+</span>bw<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> j<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>                PA<span class="op">[</span>j<span class="op">+</span>n<span class="op">*(</span>j<span class="op">-</span>i<span class="op">)]</span> <span class="op">-=</span> PA<span class="op">[</span>i<span class="op">+</span>n<span class="op">*(</span>i<span class="op">-</span>k<span class="op">)]*</span>PA<span class="op">[</span>j<span class="op">+</span>n<span class="op">*(</span>j<span class="op">-</span>k<span class="op">)];</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>    </span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>bandmat_solve(PR, x)</code> routine uses a band Cholesky factor <span class="math inline">\(R\)</span> of the matrix <span class="math inline">\(A\)</span> to solve <span class="math inline">\(Ax = b\)</span>. The <code>PR</code> input argument gives the Cholesky factor (as computed by <code>bandmat_cholesky</code>); on input the <code>x</code> argument should be set to the system right-hand side, and on output it will be the solution vector.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bandmat_solve<span class="op">(</span><span class="dt">double</span><span class="op">*</span> PR<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> head <span class="op">=</span> vecmat<span class="op">(</span>PR<span class="op">);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> head<span class="op">-&gt;</span>m<span class="op">,</span> bw <span class="op">=</span> head<span class="op">-&gt;</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Forward substitution</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> bi <span class="op">=</span> x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> dj <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> dj <span class="op">&lt;=</span> bw <span class="op">&amp;&amp;</span> dj <span class="op">&lt;=</span> i<span class="op">;</span> <span class="op">++</span>dj<span class="op">)</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            bi <span class="op">-=</span> PR<span class="op">[</span>i<span class="op">+</span>dj<span class="op">*</span>n<span class="op">]*</span>x<span class="op">[</span>i<span class="op">-</span>dj<span class="op">];</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> bi<span class="op">/</span>PR<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Backward substitution</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n<span class="op">-</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> yi <span class="op">=</span> x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> i<span class="op">+</span>bw <span class="op">&amp;&amp;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>            yi <span class="op">-=</span> PR<span class="op">[</span>j<span class="op">+(</span>j<span class="op">-</span>i<span class="op">)*</span>n<span class="op">]*</span>x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> yi<span class="op">/</span>PR<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="shape-functions" class="level1">
<h1>Shape functions</h1>
<p>A <em>shape function</em> on a reference domain is a basis function used for interpolation on that domain. We will generally use Lagrange shape functions (also called nodal shape functions), which are one at one nodal point in a reference domain and zero at the others. We want to be able to compute both the values of all shape functions at a point in the domain and also their derivatives (stored as a matris with <span class="math inline">\(d\)</span> columns for a <span class="math inline">\(d\)</span>-dimensional reference domain). Our shape function implementations all have the following interface, where the output arguments <code>N</code> and <code>dN</code> are used to store the shape function values and derivative values. If a <code>NULL</code> is given for either of these output arguments, we just skip that part of the computation.</p>
<p>The function returns the number of shape functions it computes.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="op">(*</span>shapes_t<span class="op">)(</span><span class="dt">double</span><span class="op">*,</span> <span class="dt">double</span><span class="op">*,</span> <span class="dt">double</span><span class="op">*);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our 1D shape functions are Lagrange polynomials for equally-spaced nodes in the interval <span class="math inline">\([-1, 1]\)</span>. We only go up to cubic polynomials (<span class="math inline">\(p = 3)\)</span>, as high-order polynomial interpolation through equally-spaced points is poorly behaved. When finite element codes implement very high order elements, they usually use a non-equispaced mesh (e.g.&nbsp;Gauss-Lobatto-Legendre nodes) that are better behaved for interpolation.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes1dP1<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes1dP2<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes1dP3<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The 2D P1 and P2 shape functions are tensor products of 1D P1 and P2 elements. The nodes are ordered counterclockwise, starting with the bottom left corner of the square. Thus, the P1 element has the reference domain <span class="math inline">\([-1,1]^2\)</span> and nodal points at the corners:</p>
<pre><code>3 -- 2
|    |
0 -- 1</code></pre>
<p>while for the P2 element, we include the mid-side nodes and one node in the middle (listed last):</p>
<pre><code>6 -- 5 -- 4
|         |
7    8    3
|         |
0 -- 1 -- 2</code></pre>
<p>The S2 element (part of the “serendipity family”) is identical to the P2 element except that it does not include the final node in the middle.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes2dP1<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes2dP2<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes2dS2<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we define shape functions for a triangle with the reference domain with corners at <span class="math inline">\((0,0)\)</span>, <span class="math inline">\((0,1)\)</span>, and <span class="math inline">\((1,0)\)</span>, listed in that order.</p>
<pre><code>2
| \
0--1</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shapes2dT1<span class="op">(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="mesh-geometry" class="level1">
<h1>Mesh geometry</h1>
<p>A mesh consists of an array of nodes locations <span class="math inline">\(x_j \in
\mathbb{R}^d\)</span> and an element connectivity array with <code>elt[i,j]</code> giving the node number for the <span class="math inline">\(i\)</span>th node of the <span class="math inline">\(j\)</span>th element.</p>
<p>Each element represents a subset of <span class="math inline">\(\Omega_e \subset \mathbb{R}^d\)</span> that is the image of a reference domain <span class="math inline">\(\Omega_0 \subset
\mathbb{R}^d\)</span> under a mapping <span class="math display">\[
  \chi(\xi) = \sum_{i=1}^{m} N^e_i(\xi) x_i
\]</span> where <span class="math inline">\(x_1, \ldots, x_m\)</span> are the <span class="math inline">\(m\)</span> element node positions. The functions <span class="math inline">\(N^e_i\)</span> are nodal basis functions (or Lagrange basis functions, or cardinal functions) for an interpolation set <span class="math inline">\(\xi_1,
\ldots, \xi_m \in \Omega_0\)</span>; that is <span class="math inline">\(N_i(\xi_j) = \delta_{ij}\)</span>. The reference domain nodes <span class="math inline">\(\xi_i\)</span> are typically placed at corners or on edges of the reference domain, and their images are at corresponding locations in <span class="math inline">\(\Omega_e\)</span>.</p>
<p>When the same set of nodal basis functions (also called nodal shape functions in a finite element setting) are used both for defining the geometry and for approximating a PDE solution on <span class="math inline">\(\Omega\)</span>, we call this method of describing the geometry an <em>isoparametric</em> map.</p>
<p>We generally want our mappings describing the geometry to be <em>positively oriented</em>: that is, the map <span class="math inline">\(\chi\)</span> should be invertible and have positive Jacobian determinant over all of <span class="math inline">\(\Omega_0\)</span>. This puts some restrictions on the spatial positions of the nodes; for example, if the interpolation nodes appear in counterclockwise order in the reference domain <span class="math inline">\(\Omega_0\)</span>, then the corresponding spatial nodes in <span class="math inline">\(\Omega_e\)</span> should also appear in counterclockwise. order.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> mesh_t <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mesh storage</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> X<span class="op">;</span>  <span class="co">// Node locations (d-by-numnp)</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> elt<span class="op">;</span>   <span class="co">// Element connectivity array (nen-by-numelt)</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Dimensions</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d<span class="op">;</span>       <span class="co">// Spatial dimension of problem</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp<span class="op">;</span>   <span class="co">// Number of nodal points</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen<span class="op">;</span>     <span class="co">// Number of element nodes</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numelt<span class="op">;</span>  <span class="co">// Number of elements</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Shape function</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">(*</span>shape<span class="op">)(</span><span class="dt">double</span><span class="op">*</span> N<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> x<span class="op">);</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> mesh_t<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One <em>can</em> allocate objects and then work out the node positions and element connectivity by hand (or with an external program). But in many cases, a simpler option is to programatically generate a mesh that covers a simple domain (e.g.&nbsp;a block) and then map the locations of the nodes. One can construct more complex meshes by combining this with a “tie” operation that merges the identity of nodes in the same location, but we will not bother with tied meshes for now.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>mesh_t<span class="op">*</span> malloc_mesh<span class="op">(</span><span class="dt">int</span> d<span class="op">,</span> <span class="dt">int</span> numnp<span class="op">,</span> <span class="dt">int</span> nen<span class="op">,</span> <span class="dt">int</span> numelt<span class="op">);</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free_mesh<span class="op">(</span>mesh_t<span class="op">*</span> mesh<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The simplest mesher creates a 1D mesh on an interval <span class="math inline">\([a,b]\)</span>. We allow elements of order 1-3.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>mesh_t<span class="op">*</span> mesh_create1d<span class="op">(</span><span class="dt">int</span> numelt<span class="op">,</span> <span class="dt">int</span> degree<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Things are more complicated in 2D, and we have distinct mesh generation routines for the different types of shape functions described in the <code>shapes</code> module. Each of these generates a mesh of the region <span class="math inline">\([0,1]^2\)</span> with <code>nex</code>-by-<code>ney</code> elements.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>mesh_t<span class="op">*</span> mesh_block2d_P1<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">);</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>mesh_t<span class="op">*</span> mesh_block2d_P2<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">);</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>mesh_t<span class="op">*</span> mesh_block2d_S2<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>mesh_t<span class="op">*</span> mesh_block2d_T1<span class="op">(</span><span class="dt">int</span> nex<span class="op">,</span> <span class="dt">int</span> ney<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For debugging, it is helpful to be able to print out all or part of the mesh geometry.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print_nodes<span class="op">(</span>mesh_t<span class="op">*</span> mesh<span class="op">);</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print_elt<span class="op">(</span>mesh_t<span class="op">*</span> mesh<span class="op">);</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mesh_print<span class="op">(</span>mesh_t<span class="op">*</span> mesh<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="gaussian-legendre-quadrature-rules" class="level1">
<h1>Gaussian-Legendre quadrature rules</h1>
<p>Gauss-Legendre quadrature rules (sometimes just called Gauss quadrature rules when the context is clear) approximate integrals with formulas of the form <span class="math display">\[
  \int_{-1}^1 f(x) \, dx \approx
  \sum_{j=1}^p f(\xi_{jp}) w_{jp},
\]</span> where <span class="math inline">\(\xi_{jp}\)</span> and <span class="math inline">\(w_{jp}\)</span> are referred to as the quadrature nodes (or points) and weights, respectively. Gauss quadrature rules are characterized by the fact that they are exact when <span class="math inline">\(f\)</span> is a polynomial of degree at most <span class="math inline">\(2p-1\)</span>.</p>
<p>Gauss-Legendre nodes are zeros of Legendre polynomials, while the weights can be computed via an eigenvalue decomposition (using the Golub-Welsch algorithm). However, we do not need very high-order quadrature rules, and so only provide nodes and weights for rules up to <span class="math inline">\(p = 10\)</span>, which are tabulated in many places.</p>
<p>Note that our code uses zero-based indexing (C-style) for indexing the quadrature nodes, even though the expression we wrote above uses the one-based indexing more common in presentations in the numerical methods literature.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> gauss_point<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">);</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> gauss_weight<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> npts<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="assembly" class="level1">
<h1>Assembly</h1>
<p>Each element in a finite element discretization consists of</p>
<ul>
<li>A domain <span class="math inline">\(\Omega_e\)</span> for the <span class="math inline">\(e\)</span>th element, and</li>
<li>Local shape functions <span class="math inline">\(N^e_1, \ldots, N^e_m\)</span>, which are often Lagrange functions for interpolation at some set of nodes in <span class="math inline">\(\Omega_e\)</span>.</li>
</ul>
<p>Each local shape function on the domain <span class="math inline">\(\Omega_e\)</span> is the restriction of some global shape function on the whole domain <span class="math inline">\(\Omega\)</span>. That is, we have global shape functions <span class="math display">\[
  N_{j}(x) = \sum_{j = \iota(j',e)} N^e_{j'}(x),
\]</span> where <span class="math inline">\(\iota(j,e)\)</span> denotes the mapping from the local shape function index for element <span class="math inline">\(e\)</span> to the corresponding global shape function index. We only ever compute explicitly with the local functions <span class="math inline">\(N^e_j\)</span>; the global functions are implicit.</p>
<p><em>Assembly</em> is the process of reconstructing a quantity defined in terms of global shape functions from the contributions of the individual elements and their local shape functions. For example, to compute <span class="math display">\[
  F_i = \int_{\Omega} f(x) N_i(x) \, dx,
\]</span> we rewrite the integral as <span class="math display">\[
  F_i = \sum_{i = \iota(i',e)} \int_{\Omega_e} f(x) N^e_{i'}(x) \, dx.
\]</span> In code, this is separated into two pieces:</p>
<ul>
<li>Compute element contributions <span class="math inline">\(\int_{\Omega_e} f(x) N^e_{i'}(x) \, dx\)</span>. This is the responsibility of the element implementation.</li>
<li>Sum contributions into the global position <span class="math inline">\(i\)</span> corresponding to the element-local index <span class="math inline">\(i'\)</span>. This is managed by an assembly loop.</li>
</ul>
<p>The concept of an “assembly loop” is central to finite element methods, but it is not unique to this setting. For example, circuit simulators similarly construct system matrices (conductance, capacitance, etc) via the contributions of circuit elements (resistors, capacitors, inductors, and so forth).</p>
<p>We have two types of assembly loops that we care about: those that involve pairs of shape functions and result in matrices, and those that explicitly involve only a single shape function and result in vectors.</p>
<p>We will sometimes also want to discard some element contributions that correspond to interactions with shape functions associated with known boundary values (for example). We also handle this filtering work as part of our assembly process.</p>
<section id="matrix-assembler-interface" class="level2">
<h2 class="anchored" data-anchor-id="matrix-assembler-interface">Matrix assembler interface</h2>
<p>There are several matrix formats that we might want to target as outputs for assembling a matrix; these include dense storage, banded storage, coordinate form, or CSR. Because we would like to re-use the same assembly loop logic with these different formats, we define an abstract <code>assemble_t</code> interface with two basic methods:</p>
<ul>
<li><code>add(assembler, ematrix, ids, ne)</code> adds the <code>ne</code>-by-<code>ne</code> element matrix (<code>ematrix</code>) into the global structure referenced by the assembler. The <code>ids</code> array implements the map <span class="math inline">\(\iota\)</span> from local indices to global indices (i.e.&nbsp;<code>ids[ilocal] = iglobal</code>).</li>
<li><code>clear(assembler)</code> zeros out the matrix storage in preparation for assembly of a new matrix.</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Interface for general assembler object (callback + context)</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> assemble_t <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> p<span class="op">;</span>                                <span class="co">// Context</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>add<span class="op">)(</span><span class="dt">void</span><span class="op">*,</span> <span class="dt">double</span><span class="op">*,</span> <span class="dt">int</span><span class="op">*,</span> <span class="dt">int</span><span class="op">);</span> <span class="co">// Add contribution</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>clear<span class="op">)(</span><span class="dt">void</span><span class="op">*);</span>                   <span class="co">// Clear</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> assemble_t<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Convenience functions that call the assembler methods</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_add<span class="op">(</span>assemble_t<span class="op">*</span> assembler<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">);</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_clear<span class="op">(</span>assemble_t<span class="op">*</span> assembler<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We currently only support two types of assemblers: dense and band. In all cases, we assume that the dimension <code>n</code> of the matrix is big enough (all active indices are less than <code>n</code>). For the band assembler, we do check to make sure there are no contributions that are outside the band (and error out if a contribution does live outside the expected band).</p>
<p>Both the dense and the band matrix expect pointers to data using our <code>vecmat_t</code> scheme, so we do not need to pass in explicit dimension arguments.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_assemble_dense<span class="op">(</span>assemble_t<span class="op">*</span> assembler<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> A<span class="op">);</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_assemble_band<span class="op">(</span>assemble_t<span class="op">*</span> assembler<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> b<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="vector-assembly-interface" class="level2">
<h2 class="anchored" data-anchor-id="vector-assembly-interface">Vector assembly interface</h2>
<p>We only really use one vector representation (a simple array), so there is no need for the same type of assembler abstraction for vectors that we have for matrices. The semantics of <code>assemble_vector</code> are similar to those of <code>assemble_add</code> in the matrix case, except now we add the element vector <code>ve</code> into the global vector <code>v</code>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_vector<span class="op">(</span><span class="dt">double</span><span class="op">*</span> v<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> ve<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="method-dispatch" class="level2">
<h2 class="anchored" data-anchor-id="method-dispatch">Method dispatch</h2>
<div class="sourceCode" id="cb29"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_add<span class="op">(</span>assemble_t<span class="op">*</span> assembler<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>assembler<span class="op">-&gt;</span>add<span class="op">))(</span>assembler<span class="op">-&gt;</span>p<span class="op">,</span> emat<span class="op">,</span> ids<span class="op">,</span> ne<span class="op">);</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_clear<span class="op">(</span>assemble_t<span class="op">*</span> assembler<span class="op">)</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>assembler<span class="op">-&gt;</span>clear<span class="op">))(</span>assembler<span class="op">-&gt;</span>p<span class="op">);</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Setting up an assembler object just involves initializing the data pointer <code>p</code> and setting up the method table. Note that both the dense and band storage sit on top of our <code>vecmat_t</code> array manager, so we can use the same <code>clear</code> implementation in both cases.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare private implementations for the methods</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> assemble_dense_add<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">);</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> assemble_bandmat_add<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">);</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> assemble_vecmat_clear<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">);</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Initialize a dense assembler</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_assemble_dense<span class="op">(</span>assemble_t<span class="op">*</span> assembler<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> A<span class="op">)</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>p <span class="op">=</span> A<span class="op">;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>add <span class="op">=</span> assemble_dense_add<span class="op">;</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>clear <span class="op">=</span> assemble_vecmat_clear<span class="op">;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Initialize a band assembler</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init_assemble_band<span class="op">(</span>assemble_t<span class="op">*</span> assembler<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> b<span class="op">)</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>p <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>add <span class="op">=</span> assemble_bandmat_add<span class="op">;</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>    assembler<span class="op">-&gt;</span>clear <span class="op">=</span> assemble_vecmat_clear<span class="op">;</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="matrix-assembly-loops" class="level2">
<h2 class="anchored" data-anchor-id="matrix-assembly-loops">Matrix assembly loops</h2>
<p>The assembly loops logically execute <code>A[iglobal, jglobal] += Ae[i, j]</code> for every local index pair <code>(i,j)</code>. We filter out the contributions where the global indices are negative (indicating that these contributions are not needed because of an essential boundary condition.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> assemble_dense_add<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">)</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> head <span class="op">=</span> vecmat<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> A <span class="op">=</span> head<span class="op">-&gt;</span>data<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> head<span class="op">-&gt;</span>m<span class="op">;</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> je <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> je <span class="op">&lt;</span> ne<span class="op">;</span> <span class="op">++</span>je<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> ids<span class="op">[</span>je<span class="op">];</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ie <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ie <span class="op">&lt;=</span> je<span class="op">;</span> <span class="op">++</span>ie<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ids<span class="op">[</span>ie<span class="op">];</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">&gt;=</span> i<span class="op">)</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>                A<span class="op">[</span>i<span class="op">+</span>n<span class="op">*</span>j<span class="op">]</span> <span class="op">+=</span> emat<span class="op">[</span>ie<span class="op">+</span>ne<span class="op">*</span>je<span class="op">];</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> assemble_bandmat_add<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> emat<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">)</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    vecmat_head_t<span class="op">*</span> head <span class="op">=</span> vecmat<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> P <span class="op">=</span> head<span class="op">-&gt;</span>data<span class="op">;</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> head<span class="op">-&gt;</span>m<span class="op">;</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b <span class="op">=</span> head<span class="op">-&gt;</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> je <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> je <span class="op">&lt;</span> ne<span class="op">;</span> <span class="op">++</span>je<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> ids<span class="op">[</span>je<span class="op">];</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ie <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ie <span class="op">&lt;=</span> je<span class="op">;</span> <span class="op">++</span>ie<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> ids<span class="op">[</span>ie<span class="op">];</span></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> d <span class="op">=</span> j<span class="op">-</span>i<span class="op">;</span></span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> d <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>                assert<span class="op">(</span>d <span class="op">&lt;=</span> b<span class="op">);</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>                P<span class="op">[</span>j<span class="op">+</span>n<span class="op">*</span>d<span class="op">]</span> <span class="op">+=</span> emat<span class="op">[</span>ie<span class="op">+</span>ne<span class="op">*</span>je<span class="op">];</span></span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="clearing-storage" class="level2">
<h2 class="anchored" data-anchor-id="clearing-storage">Clearing storage</h2>
<div class="sourceCode" id="cb32"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> assemble_vecmat_clear<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">)</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    vecmat_clear<span class="op">((</span><span class="dt">double</span><span class="op">*)</span> p<span class="op">);</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="vector-assembly" class="level2">
<h2 class="anchored" data-anchor-id="vector-assembly">Vector assembly</h2>
<div class="sourceCode" id="cb33"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assemble_vector<span class="op">(</span><span class="dt">double</span><span class="op">*</span> v<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> ve<span class="op">,</span> <span class="dt">int</span><span class="op">*</span> ids<span class="op">,</span> <span class="dt">int</span> ne<span class="op">)</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> ie <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ie <span class="op">&lt;</span> ne<span class="op">;</span> <span class="op">++</span>ie<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i <span class="op">=</span> ids<span class="op">[</span>ie<span class="op">];</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>            v<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> ve<span class="op">[</span>ie<span class="op">];</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="finite-element-mesh" class="level1">
<h1>Finite element mesh</h1>
<p>My finite element mesh data structure is informed by lots of old Fortran codes, and mostly is a big pile of arrays. Specifically, we have the nodal arrays:</p>
<ul>
<li><code>U</code>: Global array of solution values, <em>including</em> those that are determined by Dirichlet boundary conditions. Column <span class="math inline">\(j\)</span> represents the unknowns at node <span class="math inline">\(j\)</span> in the mesh.</li>
<li><code>F</code>: Global array of load values (right hand side evaluations of the forcing function in Poisson, for example; but Neumann boundary conditions can also contribute to <code>F</code>).</li>
<li><code>id</code>: Indices of solution values in a reduced solution vector. One column per node, with the same dimensions as <code>U</code> (and <code>F</code>), so that <code>ureduced[id[i,j]]</code> corresponds to <code>U[i,j]</code> when <code>id[i,j]</code> is positive. The reduced solution vector contains only those variables that are not constrained a priori by boundary conditions; we mark the latter with negative entries in the <code>id</code> array.</li>
</ul>
<p>We also keep around a pointer to a mesh and an element type object. Note that for the moment, we are assuming only one element type per problem – we could have a separate array of element type pointer (one per element) if we wanted more flexibility.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> fem_t <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mesh data</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> mesh_t<span class="op">*</span> mesh<span class="op">;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Element type (NB: can generalize with multiple types)</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> element_t<span class="op">*</span> etype<span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Storage for fields</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> U<span class="op">;</span>  <span class="co">// Global array of solution values (ndof-by-numnp)</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> F<span class="op">;</span>  <span class="co">// Global array of forcing values (ndof-by-numnp)</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> id<span class="op">;</span>    <span class="co">// Global to reduced ID map (ndof-by-numnp)</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Dimensions</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof<span class="op">;</span>    <span class="co">// Number of unknowns per nodal point (ndof = 1)</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nactive<span class="op">;</span> <span class="co">// Number of active dofs</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> fem_t<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="mesh-operations" class="level2">
<h2 class="anchored" data-anchor-id="mesh-operations">Mesh operations</h2>
<div class="sourceCode" id="cb35"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>fem_t<span class="op">*</span> malloc_fem<span class="op">(</span><span class="kw">struct</span> mesh_t<span class="op">*</span> mesh<span class="op">,</span> <span class="dt">int</span> ndof<span class="op">);</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free_fem<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>fem_assign_ids</code> function sets up the <code>id</code> array. On input, the <code>id</code> array in the mesh structure should be initialized so that boundary values are marked with negative numbers (and everything else non-negative). On output, entries of the <code>id</code> array for variables not subject to essential boundary conditions will be assigned indices from 0 to <code>nactive</code> (and <code>nactive</code> will be updated appropriately).</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fem_assign_ids<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>fem_update_U</code> function applies an update to the internal state. By update, we mean that <code>U[i,j] -= du_red[id[i,j]]</code> for <code>id[i,j] &gt; 0</code>.</p>
<p>If the update comes from <span class="math inline">\(K^{-1} R\)</span> where <span class="math inline">\(K\)</span> is the reduced tangent and <span class="math inline">\(R\)</span> is the reduced residual, then applying the update will exactly solve the equation in the linear case. However, we can also apply approximate updates (e.g.&nbsp;with an inexact solver for <span class="math inline">\(K\)</span>), and the same framework works for Newton iterations for nonlinear problems.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_update_U<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> du_red<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>fem_set_load</code> function iterates through all nodes in the mesh, and for each node calls a callback function. The arguments to the callback are the node position (an input argument) and the node loading / right-hand side vector (an output argument).</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_set_load<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">void</span> <span class="op">(*</span>f<span class="op">)(</span><span class="dt">double</span><span class="op">*</span> x<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> fx<span class="op">));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The assembly loops iterate through the elements and produce a global residual and tangent stiffness based on the current solution state. The residual and tangent matrix assembler are passed in by pointers; a <code>NULL</code> pointer means “do not assemble this”.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> <span class="kw">struct</span> assemble_t<span class="op">*</span> Kassembler<span class="op">);</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble_band<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> K<span class="op">);</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble_dense<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> K<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For debugging small problems, it is also useful to have a routine to print out all the mesh arrays.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_print<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<div class="sourceCode" id="cb41"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate mesh object</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>fem_t<span class="op">*</span> malloc_fem<span class="op">(</span>mesh_t<span class="op">*</span> mesh<span class="op">,</span> <span class="dt">int</span> ndof<span class="op">)</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> mesh<span class="op">-&gt;</span>numnp<span class="op">;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    fem_t<span class="op">*</span> fe <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>fem_t<span class="op">));</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>mesh    <span class="op">=</span> mesh<span class="op">;</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>etype   <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>ndof    <span class="op">=</span> ndof<span class="op">;</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>nactive <span class="op">=</span> numnp <span class="op">*</span> ndof<span class="op">;</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>U  <span class="op">=</span> <span class="op">(</span><span class="dt">double</span><span class="op">*)</span> calloc<span class="op">(</span>ndof <span class="op">*</span> numnp<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>F  <span class="op">=</span> <span class="op">(</span><span class="dt">double</span><span class="op">*)</span> calloc<span class="op">(</span>ndof <span class="op">*</span> numnp<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>id <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">*)</span>    calloc<span class="op">(</span>ndof <span class="op">*</span> numnp<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fe<span class="op">;</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a><span class="co">// Free mesh object</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free_fem<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">)</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>fe<span class="op">-&gt;</span>id<span class="op">);</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>fe<span class="op">-&gt;</span>F<span class="op">);</span></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>fe<span class="op">-&gt;</span>U<span class="op">);</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>    free_mesh<span class="op">(</span>fe<span class="op">-&gt;</span>mesh<span class="op">);</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>fe<span class="op">);</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a><span class="co">// Initialize the id array and set nactive</span></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fem_assign_ids<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">)</span></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numnp<span class="op">;</span></span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> id <span class="op">=</span> fe<span class="op">-&gt;</span>id<span class="op">;</span></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> next_id <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>id<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>            id<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_id<span class="op">++;</span></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a>    fe<span class="op">-&gt;</span>nactive <span class="op">=</span> next_id<span class="op">;</span></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> next_id<span class="op">;</span></span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a><span class="co">// Decrement U by du_red</span></span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_update_U<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> du_red<span class="op">)</span></span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> U <span class="op">=</span> fe<span class="op">-&gt;</span>U<span class="op">;</span></span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> id   <span class="op">=</span> fe<span class="op">-&gt;</span>id<span class="op">;</span></span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof  <span class="op">=</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span></span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numnp<span class="op">;</span></span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb41-50"><a href="#cb41-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb41-51"><a href="#cb41-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>id<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb41-52"><a href="#cb41-52" aria-hidden="true" tabindex="-1"></a>                U<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">]</span> <span class="op">-=</span> du_red<span class="op">[</span>id<span class="op">[</span>j<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">]];</span></span>
<span id="cb41-53"><a href="#cb41-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-54"><a href="#cb41-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-55"><a href="#cb41-55" aria-hidden="true" tabindex="-1"></a><span class="co">// Call the callback on each nodes (node position, force vector)</span></span>
<span id="cb41-56"><a href="#cb41-56" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_set_load<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">void</span> <span class="op">(*</span>f<span class="op">)(</span><span class="dt">double</span><span class="op">*</span> x<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> fx<span class="op">))</span></span>
<span id="cb41-57"><a href="#cb41-57" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-58"><a href="#cb41-58" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d     <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">;</span></span>
<span id="cb41-59"><a href="#cb41-59" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numnp <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numnp<span class="op">;</span></span>
<span id="cb41-60"><a href="#cb41-60" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof  <span class="op">=</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span></span>
<span id="cb41-61"><a href="#cb41-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> X <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>X<span class="op">;</span></span>
<span id="cb41-62"><a href="#cb41-62" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> F <span class="op">=</span> fe<span class="op">-&gt;</span>F<span class="op">;</span></span>
<span id="cb41-63"><a href="#cb41-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb41-64"><a href="#cb41-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">(*</span>f<span class="op">)(</span>X<span class="op">+</span>i<span class="op">*</span>d<span class="op">,</span> F<span class="op">+</span>i<span class="op">*</span>ndof<span class="op">);</span></span>
<span id="cb41-65"><a href="#cb41-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-66"><a href="#cb41-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-67"><a href="#cb41-67" aria-hidden="true" tabindex="-1"></a><span class="co">// Assemble global residual and tangent stiffness (general)</span></span>
<span id="cb41-68"><a href="#cb41-68" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> assemble_t<span class="op">*</span> K<span class="op">)</span></span>
<span id="cb41-69"><a href="#cb41-69" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-70"><a href="#cb41-70" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numelt       <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numelt<span class="op">;</span></span>
<span id="cb41-71"><a href="#cb41-71" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen          <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>nen<span class="op">;</span></span>
<span id="cb41-72"><a href="#cb41-72" aria-hidden="true" tabindex="-1"></a>    element_t<span class="op">*</span> etype <span class="op">=</span> fe<span class="op">-&gt;</span>etype<span class="op">;</span></span>
<span id="cb41-73"><a href="#cb41-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-74"><a href="#cb41-74" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up local storage for element contributions</span></span>
<span id="cb41-75"><a href="#cb41-75" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> ids   <span class="op">=</span>     calloc<span class="op">(</span>nen<span class="op">,</span>     <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb41-76"><a href="#cb41-76" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> Re <span class="op">=</span> R <span class="op">?</span> calloc<span class="op">(</span>nen<span class="op">,</span>     <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">))</span> <span class="op">:</span> NULL<span class="op">;</span></span>
<span id="cb41-77"><a href="#cb41-77" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> Ke <span class="op">=</span> K <span class="op">?</span> calloc<span class="op">(</span>nen<span class="op">*</span>nen<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">))</span> <span class="op">:</span> NULL<span class="op">;</span></span>
<span id="cb41-78"><a href="#cb41-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-79"><a href="#cb41-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Clear storage for assembly</span></span>
<span id="cb41-80"><a href="#cb41-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>R<span class="op">)</span> memset<span class="op">(</span>R<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> fe<span class="op">-&gt;</span>nactive <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb41-81"><a href="#cb41-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>K<span class="op">)</span> assemble_clear<span class="op">(</span>K<span class="op">);</span></span>
<span id="cb41-82"><a href="#cb41-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-83"><a href="#cb41-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Assemble contributions</span></span>
<span id="cb41-84"><a href="#cb41-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numelt<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-85"><a href="#cb41-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-86"><a href="#cb41-86" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Get element contributions</span></span>
<span id="cb41-87"><a href="#cb41-87" aria-hidden="true" tabindex="-1"></a>        element_dR<span class="op">(</span>etype<span class="op">,</span> fe<span class="op">,</span> i<span class="op">,</span> Re<span class="op">,</span> Ke<span class="op">);</span></span>
<span id="cb41-88"><a href="#cb41-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-89"><a href="#cb41-89" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Figure out where to put them</span></span>
<span id="cb41-90"><a href="#cb41-90" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> elt <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>elt <span class="op">+</span> i<span class="op">*</span>nen<span class="op">;</span></span>
<span id="cb41-91"><a href="#cb41-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb41-92"><a href="#cb41-92" aria-hidden="true" tabindex="-1"></a>            ids<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> fe<span class="op">-&gt;</span>id<span class="op">[</span>elt<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb41-93"><a href="#cb41-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-94"><a href="#cb41-94" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Put them into the global vector/matrix</span></span>
<span id="cb41-95"><a href="#cb41-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>R<span class="op">)</span> assemble_vector<span class="op">(</span>R<span class="op">,</span> Re<span class="op">,</span> ids<span class="op">,</span> nen<span class="op">);</span></span>
<span id="cb41-96"><a href="#cb41-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>K<span class="op">)</span> assemble_add<span class="op">(</span>K<span class="op">,</span> Ke<span class="op">,</span> ids<span class="op">,</span> nen<span class="op">);</span></span>
<span id="cb41-97"><a href="#cb41-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-98"><a href="#cb41-98" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-99"><a href="#cb41-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-100"><a href="#cb41-100" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Free local storage</span></span>
<span id="cb41-101"><a href="#cb41-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Ke<span class="op">)</span> free<span class="op">(</span>Ke<span class="op">);</span></span>
<span id="cb41-102"><a href="#cb41-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Re<span class="op">)</span> free<span class="op">(</span>Re<span class="op">);</span></span>
<span id="cb41-103"><a href="#cb41-103" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>ids<span class="op">);</span></span>
<span id="cb41-104"><a href="#cb41-104" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-105"><a href="#cb41-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-106"><a href="#cb41-106" aria-hidden="true" tabindex="-1"></a><span class="co">// Convenience function for assembling band matrix</span></span>
<span id="cb41-107"><a href="#cb41-107" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble_band<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> K<span class="op">)</span></span>
<span id="cb41-108"><a href="#cb41-108" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-109"><a href="#cb41-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-110"><a href="#cb41-110" aria-hidden="true" tabindex="-1"></a>        assemble_t Kassembler<span class="op">;</span></span>
<span id="cb41-111"><a href="#cb41-111" aria-hidden="true" tabindex="-1"></a>        init_assemble_band<span class="op">(&amp;</span>Kassembler<span class="op">,</span> K<span class="op">);</span></span>
<span id="cb41-112"><a href="#cb41-112" aria-hidden="true" tabindex="-1"></a>        fem_assemble<span class="op">(</span>fe<span class="op">,</span> R<span class="op">,</span> <span class="op">&amp;</span>Kassembler<span class="op">);</span></span>
<span id="cb41-113"><a href="#cb41-113" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb41-114"><a href="#cb41-114" aria-hidden="true" tabindex="-1"></a>        fem_assemble<span class="op">(</span>fe<span class="op">,</span> R<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb41-115"><a href="#cb41-115" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-116"><a href="#cb41-116" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-117"><a href="#cb41-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-118"><a href="#cb41-118" aria-hidden="true" tabindex="-1"></a><span class="co">// Convenience function for assembling dense matrix</span></span>
<span id="cb41-119"><a href="#cb41-119" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_assemble_dense<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> R<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> K<span class="op">)</span></span>
<span id="cb41-120"><a href="#cb41-120" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-121"><a href="#cb41-121" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-122"><a href="#cb41-122" aria-hidden="true" tabindex="-1"></a>        assemble_t Kassembler<span class="op">;</span></span>
<span id="cb41-123"><a href="#cb41-123" aria-hidden="true" tabindex="-1"></a>        init_assemble_dense<span class="op">(&amp;</span>Kassembler<span class="op">,</span> K<span class="op">);</span></span>
<span id="cb41-124"><a href="#cb41-124" aria-hidden="true" tabindex="-1"></a>        fem_assemble<span class="op">(</span>fe<span class="op">,</span> R<span class="op">,</span> <span class="op">&amp;</span>Kassembler<span class="op">);</span></span>
<span id="cb41-125"><a href="#cb41-125" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb41-126"><a href="#cb41-126" aria-hidden="true" tabindex="-1"></a>        fem_assemble<span class="op">(</span>fe<span class="op">,</span> R<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb41-127"><a href="#cb41-127" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-128"><a href="#cb41-128" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-129"><a href="#cb41-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-130"><a href="#cb41-130" aria-hidden="true" tabindex="-1"></a><span class="co">// Print mesh state</span></span>
<span id="cb41-131"><a href="#cb41-131" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fem_print<span class="op">(</span>fem_t<span class="op">*</span> fe<span class="op">)</span></span>
<span id="cb41-132"><a href="#cb41-132" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-133"><a href="#cb41-133" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Nodal information:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb41-134"><a href="#cb41-134" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"       ID "</span><span class="op">);</span></span>
<span id="cb41-135"><a href="#cb41-135" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> printf<span class="op">(</span><span class="st">"     X</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb41-136"><a href="#cb41-136" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span>   printf<span class="op">(</span><span class="st">"     U</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb41-137"><a href="#cb41-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span>   printf<span class="op">(</span><span class="st">"     F</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb41-138"><a href="#cb41-138" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb41-139"><a href="#cb41-139" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>numnp<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-140"><a href="#cb41-140" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%3d</span><span class="st"> : </span><span class="sc">% 3d</span><span class="st"> "</span><span class="op">,</span> i<span class="op">,</span> fe<span class="op">-&gt;</span>id<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb41-141"><a href="#cb41-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb41-142"><a href="#cb41-142" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">" </span><span class="sc">%6.2g</span><span class="st">"</span><span class="op">,</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>X<span class="op">[</span>j<span class="op">+</span>fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">*</span>i<span class="op">]);</span></span>
<span id="cb41-143"><a href="#cb41-143" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb41-144"><a href="#cb41-144" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">" </span><span class="sc">% 6.2g</span><span class="st">"</span><span class="op">,</span> fe<span class="op">-&gt;</span>U<span class="op">[</span>j<span class="op">+</span>fe<span class="op">-&gt;</span>ndof<span class="op">*</span>i<span class="op">]);</span></span>
<span id="cb41-145"><a href="#cb41-145" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb41-146"><a href="#cb41-146" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">" </span><span class="sc">% 6.2g</span><span class="st">"</span><span class="op">,</span> fe<span class="op">-&gt;</span>F<span class="op">[</span>j<span class="op">+</span>fe<span class="op">-&gt;</span>ndof<span class="op">*</span>i<span class="op">]);</span></span>
<span id="cb41-147"><a href="#cb41-147" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb41-148"><a href="#cb41-148" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-149"><a href="#cb41-149" aria-hidden="true" tabindex="-1"></a>    mesh_print_elt<span class="op">(</span>fe<span class="op">-&gt;</span>mesh<span class="op">);</span></span>
<span id="cb41-150"><a href="#cb41-150" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="elements" class="level1">
<h1>Elements</h1>
<p>Abstractly, for steady-state problems, we are finding <span class="math inline">\(u(x) = \sum_j N_j(x) u_j\)</span> via an equation <span class="math display">\[
  R(u, N_i) = 0
\]</span> for all shape functions <span class="math inline">\(N_i\)</span> that are not associated with essential boundary conditions. The element routines compute the contribution of one element to the residual <span class="math inline">\(R\)</span> and to the tangent <span class="math inline">\(\partial R/\partial u_j\)</span>.</p>
<p>Different types of equations demand different types of elements. Even for a single type of element, we may depend on things like PDE coefficients or choices of material parameters (as well as implementation details like the quadrature rule used for computing integrals). An <code>element_t</code> object type keeps all this information together. The <code>element_t</code> data type should be thought of as representing a <em>type</em> of element, and not one specific element; usually many elements share fundamentally the same data, differing only in which nodes they involve. In the language of design patterns, this is an example of a “flyweight” pattern.</p>
<p>The main interface for an element is a method</p>
<pre><code>dR(p, fe, eltid, Re, Ke)</code></pre>
<p>where <code>p</code> is context data for the element type, <code>fe</code> is a finite element mesh data structure, <code>eltid</code> is the index of the element in the mesh, and <code>Re</code> and <code>Ke</code> are pointers to storage for the element residual and tangent matrix contributions. Either <code>Re</code> or <code>Ke</code> can be null, indicating that we don’t need that output.</p>
<p>We also provide a destructor method (<code>free</code>) for releasing resources used by the <code>element_t</code> instance.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Element type interface</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> element_t <span class="op">{</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>p<span class="op">;</span> <span class="co">// Context pointer</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>dR<span class="op">)(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> <span class="kw">struct</span> fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>              <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">);</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>free<span class="op">)(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">);</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> element_t<span class="op">;</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Wrappers for calling the dR and free method</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> element_dR<span class="op">(</span>element_t<span class="op">*</span> e<span class="op">,</span> <span class="kw">struct</span> fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">);</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free_element<span class="op">(</span>element_t<span class="op">*</span> e<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Write now, we only have one element type, corresponding to a 1D Poisson problem, written in weak form as <span class="math display">\[
R(u, N_i) =
\int_{\Omega} \left(
\nabla N_i(x) \cdot \nabla u(x) -
N_i(x) f(x) \right) \, d\Omega(x).
\]</span> There are no PDE coefficients or other special parameters to keep track of for this element tyle.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>element_t<span class="op">*</span> malloc_poisson_element<span class="op">();</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="method-dispatch-1" class="level2">
<h2 class="anchored" data-anchor-id="method-dispatch-1">Method dispatch</h2>
<p>As usual for when we do OOP in C, we have dispatch functions that essentially trampoline a call to the appropriate function pointer in an element object’s dispatch table.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Call element dR method</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> element_dR<span class="op">(</span>element_t<span class="op">*</span> e<span class="op">,</span> <span class="kw">struct</span> fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>                <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">)</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>e<span class="op">-&gt;</span>dR<span class="op">))(</span>e<span class="op">-&gt;</span>p<span class="op">,</span> fe<span class="op">,</span> eltid<span class="op">,</span> Re<span class="op">,</span> Ke<span class="op">);</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Call element free</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free_element<span class="op">(</span>element_t<span class="op">*</span> e<span class="op">)</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*(</span>e<span class="op">-&gt;</span>free<span class="op">))(</span>e<span class="op">-&gt;</span>p<span class="op">);</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We write our Poisson interface to illustrate the general pattern, even though we could in principle simplify it (because we are not carrying around any element parameters in this case). The internal wiring is:</p>
<ul>
<li>Element type data is stored in a structure like <code>poisson_elt_t</code>.</li>
<li>One field of the specific element is an <code>element_t</code> containing the methods table for the element.</li>
<li>The data pointer in the <code>element_t</code> field points back to the containing struct (the <code>poisson_elt_t</code> in this case).</li>
</ul>
<p>Externally, we always pass around <code>element_t</code> pointers. Internally, we always use the more specific <code>poisson_elt_t</code> from the <code>element_t</code> data pointer.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Poisson element type data structure</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> poisson_elt_t <span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Material parameters, etc go here in more complex cases</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    element_t e<span class="op">;</span> <span class="co">// For dispatch table</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> poisson_elt_t<span class="op">;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare methods for Poisson element type</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> poisson_elt_dR<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">,</span> fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>                           <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">);</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> poisson_elt_free<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">);</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocate a Poisson element type</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>element_t<span class="op">*</span> malloc_poisson_element<span class="op">()</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    poisson_elt_t<span class="op">*</span> le <span class="op">=</span> <span class="op">(</span>poisson_elt_t<span class="op">*)</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>poisson_elt_t<span class="op">));</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>p <span class="op">=</span> le<span class="op">;</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>dR <span class="op">=</span> poisson_elt_dR<span class="op">;</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    le<span class="op">-&gt;</span>e<span class="op">.</span>free <span class="op">=</span> poisson_elt_free<span class="op">;</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;(</span>le<span class="op">-&gt;</span>e<span class="op">);</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a><span class="co">// Free a Poisson element type</span></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> poisson_elt_free<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">)</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="mapped-quadrature" class="level2">
<h2 class="anchored" data-anchor-id="mapped-quadrature">Mapped quadrature</h2>
<p>We previously defined quadrature rules and element shape functions on a reference domain <span class="math inline">\([-1, 1]\)</span>; but our element subdomains are not all simple copies of this reference domain! Hence, we need a recipe for converting our rule on a reference domain with coordinates <span class="math inline">\(\xi\)</span> into a rule on an element domain in real space with coordinates <span class="math inline">\(x\)</span>.</p>
<p>A <em>mapped</em> quadrature rule uses a coordinate mapping <span class="math inline">\(x = \chi(\xi)\)</span> to convert integrals over the element domain to integrals over the reference domain. A standard choice for <span class="math inline">\(\chi\)</span> in the case of nodal shape functions is the <em>isoparametric map</em> that interpolates the nodal coordinates using the shape functions: <span class="math display">\[
  \chi(\xi) = \sum_{i=1}^m N^e_i(\xi) x_i
\]</span> where <span class="math inline">\(x_i\)</span> is the location of node <span class="math inline">\(i\)</span>. We can also compute the Jacobian matrix (1-by-1 for 1D problems) <span class="math display">\[
J(\xi) = \chi'(\xi) = \sum_{i=1}^m (N^e_i)'(\xi).
\]</span></p>
<p>The change of variables formula for integration allows us to map integrals in our real element domain back to reference domain: <span class="math display">\[
\int_{\Omega_e} f(x) \, dx =
\int_{\Omega_0} f(x(\xi))
  \det\left( \frac{\partial \chi}{\partial \xi} \right) \, d\xi.
\]</span> Applying a quadrature rule with nodes <span class="math inline">\(\xi_i\)</span> and weights <span class="math inline">\(w_i\)</span> to the reference domain integral, we have <span class="math display">\[
\int_{\Omega_e} f(x) \, dx \approx
\sum_j f(x(\xi_j)) \, \tilde{w}_j
\]</span> where <span class="math inline">\(\tilde{w}_j = \det(J(\xi_j))\)</span> with <span class="math inline">\(J(\xi)\)</span> denoting the Jacobian <span class="math inline">\(\partial \xi/\partial \xi\)</span>. Note that we assume that the Jacobian determinant of the mapping is positive.</p>
<p>Our weak forms generally involve derivatives of shape functions in <span class="math inline">\(x\)</span>, but we so far only have the derivatives of the shape functions with respect to <span class="math inline">\(\xi\)</span>. Converting derivatives in reference coordinates to spatial derivatives again involves the Jacobian determinant: <span class="math display">\[
  \frac{\partial N_i}{\partial x} =
  \frac{\partial N_i}{\partial \xi} J(\xi)^{-1}.
\]</span> We note a (standard) abuse of notation here: the symbol <span class="math inline">\(N_i\)</span> on the left hand side equation is technically the reference shape function <span class="math inline">\(N_i\)</span> composed with the inverse coordinate mapping <span class="math inline">\(\chi^{-1}\)</span>.</p>
<p>Putting this all together, we want a function that at each quadrature node <span class="math inline">\(\xi_k\)</span> will</p>
<ul>
<li>Compute shape functions and derivatives in the reference domain</li>
<li>Use the isoparametric map to compute <span class="math inline">\(x_k = \chi(\xi_k)\)</span> and <span class="math inline">\(J_k = \chi'(\xi_k)\)</span>.</li>
<li>Use <span class="math inline">\(J_k\)</span> to transform to spatial derivatives of the shape functions.</li>
<li>Use <span class="math inline">\(J_k\)</span> to compute the mapped quadrature weight.</li>
</ul>
<p>The following local function does all these steps (in 1D).</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> set_qpoint1d<span class="op">(</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> N<span class="op">,</span>     <span class="co">// Shape functions at kth point</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> dN<span class="op">,</span>    <span class="co">// dN/dx at kth point</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> xout<span class="op">,</span>  <span class="co">// Location x of kth point</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> wtout<span class="op">,</span> <span class="co">// Quadrature weight (with Jacobian)</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    fem_t<span class="op">*</span> fe<span class="op">,</span>     <span class="co">// Finite element mesh structure</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> elt<span class="op">,</span>      <span class="co">// Connectivity for current element</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k<span class="op">)</span>         <span class="co">// Index of quadrature point</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d      <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>d<span class="op">;</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen    <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>nen<span class="op">;</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> degree <span class="op">=</span> nen<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get reference domain quantities</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> xi <span class="op">=</span> gauss_point<span class="op">(</span>k<span class="op">,</span> degree<span class="op">);</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> wt <span class="op">=</span> gauss_weight<span class="op">(</span>k<span class="op">,</span> degree<span class="op">);</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*</span>fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>shape<span class="op">)(</span>N<span class="op">,</span> dN<span class="op">,</span> <span class="op">&amp;</span>xi<span class="op">);</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map xi to spatial domain (and derivative dx/dxi)</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dx_dxi <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> X <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>X<span class="op">;</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ni <span class="op">=</span> elt<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+=</span> N<span class="op">[</span>i<span class="op">]*</span>X<span class="op">[</span>ni<span class="op">*</span>d<span class="op">];</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>        dx_dxi <span class="op">+=</span> dN<span class="op">[</span>i<span class="op">]*</span>X<span class="op">[</span>ni<span class="op">*</span>d<span class="op">];</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Transform gradients and quadrature weight</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>        dN<span class="op">[</span>i<span class="op">]</span> <span class="op">/=</span> dx_dxi<span class="op">;</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>    wt <span class="op">*=</span> dx_dxi<span class="op">;</span></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set output parameters</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>xout <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>wtout <span class="op">=</span> wt<span class="op">;</span></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="d-poisson-element" class="level2">
<h2 class="anchored" data-anchor-id="d-poisson-element">1D Poisson element</h2>
<p>The 1D Poisson element <code>dR</code> routine computes the local residual terms <span class="math display">\[
R^e(u, N^e_i(x)) =
\int_{\Omega_e}
\left( \nabla N^e_i(x) \cdot \nabla u(x) - N^e_i(x) f(x) \right) \,
d\Omega(x).
\]</span> The functions <span class="math inline">\(u(x)\)</span> is represented on <span class="math inline">\(\Omega_e\)</span> in terms of the element shape functions <span class="math display">\[
  u(x) = \sum_i N^e_i(x) u_i
\]</span> and similarly for <span class="math inline">\(f(x)\)</span>. The tangent matrix has entries <span class="math display">\[
\partial ( R^e(u(x), N^e_i(x)) )/\partial u_j =
\int_{\Omega_e} \nabla N^e_i(x) \cdot \nabla N^e_j(x) \, d\Omega(x).
\]</span> We organize the computation of the integrals (both for the residual vector and the tangent matrix) as an outer loop over quadrature nodes and inner loops over the shape function indices at the quadrature node.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> poisson_elt_dR<span class="op">(</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> p<span class="op">,</span>                   <span class="co">// Context pointer (not used)</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    fem_t<span class="op">*</span> fe<span class="op">,</span> <span class="dt">int</span> eltid<span class="op">,</span>      <span class="co">// Mesh and element ID in mesh</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> Re<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> Ke<span class="op">)</span>    <span class="co">// Outputs: element residual and tangent</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nen  <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>nen<span class="op">;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ndof <span class="op">=</span> fe<span class="op">-&gt;</span>ndof<span class="op">;</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> degree <span class="op">=</span> nen<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nquad <span class="op">=</span> degree<span class="op">;</span> <span class="co">// Would need one more for mass matrix...</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> elt <span class="op">=</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>elt <span class="op">+</span> eltid<span class="op">*</span>nen<span class="op">;</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Clear element storage</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Re<span class="op">)</span> memset<span class="op">(</span>Re<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nen<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Ke<span class="op">)</span> memset<span class="op">(</span>Ke<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nen<span class="op">*</span>nen<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> nquad<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Get information about quadrature point (spatial)</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> N<span class="op">[</span><span class="dv">4</span><span class="op">];</span>  <span class="co">// Storage for shape functions</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> dN<span class="op">[</span><span class="dv">4</span><span class="op">];</span> <span class="co">// Storage for shape derivatives        </span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> x<span class="op">,</span> wt<span class="op">;</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>        set_qpoint1d<span class="op">(</span>N<span class="op">,</span> dN<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>wt<span class="op">,</span> fe<span class="op">,</span> fe<span class="op">-&gt;</span>mesh<span class="op">-&gt;</span>elt <span class="op">+</span> eltid<span class="op">*</span>nen<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add residual</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>Re<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> du <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> fx <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span><span class="op">*</span> U <span class="op">=</span> fe<span class="op">-&gt;</span>U<span class="op">;</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span><span class="op">*</span> F <span class="op">=</span> fe<span class="op">-&gt;</span>F<span class="op">;</span></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>                du <span class="op">+=</span> dN<span class="op">[</span>j<span class="op">]*</span>U<span class="op">[</span>ndof<span class="op">*</span>elt<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>                fx <span class="op">+=</span> N<span class="op">[</span>j<span class="op">]*</span>F<span class="op">[</span>ndof<span class="op">*</span>elt<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>                Re<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> <span class="op">(</span>dN<span class="op">[</span>i<span class="op">]*</span>du <span class="op">-</span> N<span class="op">[</span>i<span class="op">]*</span>fx<span class="op">)</span> <span class="op">*</span> wt<span class="op">;</span></span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add tangent stiffness</span></span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>Ke<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nen<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>                    Ke<span class="op">[</span>i<span class="op">+</span>j<span class="op">*</span>nen<span class="op">]</span> <span class="op">+=</span> dN<span class="op">[</span>i<span class="op">]*</span>dN<span class="op">[</span>j<span class="op">]</span> <span class="op">*</span> wt<span class="op">;</span></span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>